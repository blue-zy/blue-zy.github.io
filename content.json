{"meta":{"title":"Blue Cat","subtitle":"","description":"","author":"zy","url":"https://zhouyi.me","root":"/"},"pages":[{"title":"关于","date":"2021-08-13T16:00:00.000Z","updated":"2022-08-17T18:06:21.972Z","comments":false,"path":"about.html","permalink":"https://zhouyi.me/about.html","excerpt":"","text":"关于我 一名起晚贪黑的打工人，就职于宇宙厂。 关于博客 其一，日常编程操作有时会碰到一些一用就忘，一查就会的知识，故为了加深学习和方便自己查询建立此博客。 其二，编程的世界如同广阔的宇宙，探索的道路远比我们想象的更长，希望自己在探索的过程中能够留下点东西。 另外，此博客是用懒人式静态博客搭建方案github.io+hexo。 采用的hexo主题在此：https://github.com/cofess/hexo-theme-pure"},{"title":"分类","date":"2022-02-12T12:18:15.687Z","updated":"2022-02-12T12:18:15.687Z","comments":false,"path":"categories/index.html","permalink":"https://zhouyi.me/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-02-12T12:18:15.687Z","updated":"2022-02-12T12:18:15.687Z","comments":true,"path":"links/index.html","permalink":"https://zhouyi.me/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-02-12T12:18:15.724Z","updated":"2022-02-12T12:18:15.724Z","comments":false,"path":"repository/index.html","permalink":"https://zhouyi.me/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-02-12T12:18:15.725Z","updated":"2022-02-12T12:18:15.725Z","comments":false,"path":"tags/index.html","permalink":"https://zhouyi.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2022年年中小总结","slug":"日记/2022年年中小总结","date":"2022-08-17T17:52:33.000Z","updated":"2022-08-17T18:42:15.538Z","comments":true,"path":"2022/08/18/日记/2022年年中小总结/","link":"","permalink":"https://zhouyi.me/2022/08/18/%E6%97%A5%E8%AE%B0/2022%E5%B9%B4%E5%B9%B4%E4%B8%AD%E5%B0%8F%E6%80%BB%E7%BB%93/","excerpt":"打着游戏看着直播，直播里又放着某up主自制魔鬼司令的视频，突然就想写小作文了。","text":"打着游戏看着直播，直播里又放着某up主自制魔鬼司令的视频，突然就想写小作文了。 自从经过三四月份回国隔离，五月份的搬家，再到各地疫情解封，如今我已经人在上海，入职也将近四个月了。 这半年时间里，压力相对没有那么大了，抱着摆烂的心态直到入职。在此期间也一直没有想着去更新博客，去学习新知识。其实想想也挺好的，时时刻刻紧绷才容易变成想要逃避的样子，虽然这几个月因为种种原因，又因为疫情过得也挺无聊的，但也过得非常轻松，尤其是刚入职不久还仍然是居家办公的时候，时不时跟家人出去吃吃饭，感觉也很惬意。突然又想到了 mentor 大哥哥当时跟我说的，珍惜现在没有事做的日子吧，hhh。 现在恢复线下办公的模式也慢慢适应了，当面问问题真的比线上好太多了，最主要是大家熟起来了一切其实就都好办了，虽然工作上的事情也多多少少掌握了一些，但其实时不时还是会有烦恼，有时候忙得很晚感觉很充实但又感觉只是慢慢变成了一个熟练工？ 现在，总结起来还是发现自己有太多需要去学习的了，从基础开始学习的那种。希望以后能够好好规划工作时间，提高效率，争取留下学习时间，下班之后继续卷还是不太合适，怕让自己反感了。感觉成为一个很专业的人真的会很酷，会有种尽在掌握之中的成就感。 还有就是今天看到直播里放的视频，也真的好想做点什么东西出来，好不容易大学读了一个软硬件都接触的专业，明明就更有机会去实现不去做的话也好可惜，其实也想学着发发视频分享分享看看。 最后就是希望真的能瘦下来变得酷酷的。","categories":[{"name":"日记","slug":"日记","permalink":"https://zhouyi.me/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://zhouyi.me/tags/%E6%97%A5%E8%AE%B0/"},{"name":"总结","slug":"总结","permalink":"https://zhouyi.me/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"Hello World","slug":"其他/hello-world","date":"2022-02-12T12:18:15.682Z","updated":"2022-02-12T12:18:15.682Z","comments":true,"path":"2022/02/12/其他/hello-world/","link":"","permalink":"https://zhouyi.me/2022/02/12/%E5%85%B6%E4%BB%96/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new \"My New Post\" More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[{"name":"test","slug":"test","permalink":"https://zhouyi.me/categories/test/"}],"tags":[]},{"title":"2021年终总结","slug":"日记/2021年终总结","date":"2021-12-31T16:44:24.000Z","updated":"2022-02-12T12:18:15.686Z","comments":true,"path":"2022/01/01/日记/2021年终总结/","link":"","permalink":"https://zhouyi.me/2022/01/01/%E6%97%A5%E8%AE%B0/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","excerpt":"2021年的回顾与2022年的展望。","text":"2021年的回顾与2022年的展望。 按照年份来算，今年是我在日本的第三年了，回到当初刚来日本的时候，2019年那时的我在想什么呢？ 当时应该还处在一个一腔热血的阶段，研究室的中国人学长也还没有毕业，氛围也没有现在那么自闭，而且也亲眼见识到他们的厉害之处，比如中日英三语无障碍切换之类的，linux命令信手拈来之类的，也听说过再上一届的学长有去腾讯的，之前的研究生有考上东大的，有各种line，softbank的内定的，大概在幻想美好未来吧，但是这确实是幻想，和之前对种种虚无缥缈遥不可及的未来一样的幻想。 这可能就是当时的我的想法吧，现在回想起来，怎么出了国还没有长大呢？从小开始，这种没有计划性的幻想就一直没有执行的动力，没有出发的起点，基本上无一例外全部都变成了要是，假如。 另外我也很羡慕当时的自己，首先一点就是年轻啊，多出两年的时间可以好好去做很多事情，另一点则是这种美好幻想的心态，当时的身心是远没有现在这么疲惫的，羡慕这一颗充满活力的内心，但是也庆幸最后的转变收拾好了情绪，整顿好了自己，面对很多事情也变得更加波澜不惊了。 从什么时候开始真正改变的呢？现在回头来看，真正改变的时候大概是我下定决心好好找一份还能过得去的工作的时候吧。不难想象如果几个月之前我还是按照以往的心态，得过且过，现在估计还是不会脱离焦虑的困境。唉，两年前的我应该不会想到将会是这么痛苦的留学经历，从没有计划到自闭，从自闭再到逃避。 我们每一个人都会遇到孤独，因为人的一生就是孤独的，可怕的并不是孤独，可怕的是你没有办法接受，而去走上了原本你不应该走上的道路，这是当时看的一个小视频的up主的一句话，可能就是人家视频中顺口说的一句鸡汤式发言，对我的帮助却非常大，突然一瞬间就开窍了，还是非常感激的。是啊，刚来留学的时候我期望的道路，现在的我又究竟偏离了多远。好在及时抓住了最后的机会，重新踏上旅程。 悟已往之不谏，知来者之可追。 回顾这一年，还是直接来总结这两年的生活吧，如今最后悔的莫过于那段逃离现实沉迷游戏的日子里，犯了一个又一个错误，但每次都是获得短暂的快感之后又陷入无尽的空虚，然而又无法面对现实的自己，恶性循环。如果要说好的一面的话，及时修满了学分，也做出了研究课题，最差的情况也不会影响到毕业，还有硬要说的话，可能就是我还活着，毕竟我曾经竟然觉得出门被车撞死是一种解脱，因为如果真的要自行了断的话还是无法下手。 2020年，也是我正式入学的第一年，甚至可以说我没有真正在活着。庆幸的是我认识了一群很好的朋友，度过了一段非常美好的时光，可能这也是支撑着当时的我的一个点，虽然大家现在都很忙基本上都不联系了，但人本来就是孤独的，每一个阶段都会有每一个阶段的朋友，现在的我多多少少能够明白一点这些道理。 2021年，在修完必修课程之后，辞了兼职，慢慢适应了研究室研究的节奏，要说最有成就感的时候，还是写论文或者做报告的时候，虽然这个阶段修修改改非常痛苦，但这是有成就感的痛苦，也就没有那么痛苦了，另外每次看到老师密密麻麻的红色字体的评论，感觉到自己还是有被尊重的，并没有想象中的那么糟，这一点非常感激我的老师。再到后面下定决心准备秋招，网上认识了一群志同道合的也在努力的同学，自己那空虚的内心也终于能够被填满了，在此过程中，我才明白自己究竟想要做什么，想要成为什么样的人，并且包括为此需要作出怎样的努力和准备。依然记得当初打开leetcode，牛客网都会大口喘气，鸭梨山大，心酸的同时又有点想笑。不过至此，我也完全明白了并不是变得很厉害才能去做，而是只有去做了才有可能变得很厉害。 总的来说，我还是心怀感激的，对这个又恨又爱的留学期间。但从结果上来说，我真正地成长了。人生总会有低谷期，如果能在某一个时期发现自己成长了，我觉得就够了，不用再去计较这段时期的得失了，这就是最大的收获。 再说说进展和展望吧，虽然没有能够在一个很好的起点出发，但是至此还是获得了一个自己比较满意的进展，随着2021年最后一天的到来，我应该也结束了秋招的最后一场面试，如果有幸通过，也有可能是整个校招的最后一场面试了。在接下来的日子里，写完论文的话，我想以现在的心态重新去提升自己的技术知识储备，我很期待这个过程，我觉得这一次应该是真的能够变得很厉害，因为我已经做好了觉悟，并且对于自己的觉悟也有足够的信心。 一息若存，希望不灭。","categories":[{"name":"日记","slug":"日记","permalink":"https://zhouyi.me/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://zhouyi.me/tags/%E6%97%A5%E8%AE%B0/"},{"name":"总结","slug":"总结","permalink":"https://zhouyi.me/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"Java集合以及字符串常用方法","slug":"Java/Java集合以及字符串常用方法","date":"2021-11-03T03:19:00.000Z","updated":"2022-08-17T17:56:01.456Z","comments":true,"path":"2021/11/03/Java/Java集合以及字符串常用方法/","link":"","permalink":"https://zhouyi.me/2021/11/03/Java/Java%E9%9B%86%E5%90%88%E4%BB%A5%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"目录 目录 字符串相关 集合相关 字符串相关 String substring(int start);或者 substring(int index1, int index2); 左闭右开 equals(); equalsIgnoreCase(); 后者不区分大小写 charAt(int index); 获取字符，返回char getChars(int index, int index2, char[] dst, int dstStart); 左闭右开获取多个字符到dst数组，dst从dstStart开始存储。 compareTo(); 比较字符串 trim(); 去头部尾部的空格 split(String regex); 返回字符串数组，按照regex进行分隔，一般是&quot;&quot;或者&quot; &quot; toCharArray(); 返回字符数组char[] String.copyValueOf(char[] value, int offset, int count) 返回一个字符串，在value里从offset开始拷贝count个字符 indexOf(String str); 获取子串第一次出现的index，没有则返回-1 lastIndexOf(String str); 获取子串最后一次出现的index，没有则返回-1 replaceAll(String regex, String replacement); 用replacement替换所有regex字符串。 replace(char char1, char char2); 用char2替换所有char1。 toLowerCase(); toUpperCase(); String.valueOf();取字符串值，可传入基本类型 StringBuilder append(String str); toString(); setCharAt(int index, char c); 将index位置替换成c insert(int offset, String str);或者insert(int offset, char c); 从offset开始插入字符串或者字符 delete(int start, int end); 左闭右开区间 删除 集合相关 Collection add(Object obj); clear(); contains(Object o); isEmpty(); iterator(); 返回迭代器 Iterator类型 size(); List add(Object obj)或者add(int index, Object obj); 在index位置上添加元素 addAll(int index, Collection e); indexOf(Object o); lastIndexOf(); get(index); remove(index); 返回被删除的元素。 set(int index, Object obj); 修改index位置的元素，返回被修改的元素。 LinkedList特有 addFirst(Object obj); addLast(Object obj; 和add()一样，所以不常用 getFirst(); getLast(); removeFirst(); removeLast(); Stack 继承于Vector，由于Vector也是通过数组实现的，说明stack也是通过数组实现的 peek(); pop(); push(Object o); Queue接口 子接口有Deque双端队列 一般常见LinkedList实现 add(Object o); element(); offer(Object o); peek(); poll(); remove(); Set add(Object o); 不存在则插入，存在则返回false addAll(Collection c); clear(); contains(Object o); containsAll(Collection c); remove(Object o); removeAll(Collection c); Map containsKey(Object key); containsValue(Object value); entrySet(); 返回key-value的Set集合，返回值类型为Set Entry getKey(); getValue(); setValue(Object obj); keySet(); 返回key的Set集合 values(); 返回values的集合 Collection类型 put(key, value); get(key); remove(key);","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouyi.me/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouyi.me/tags/Java/"}]},{"title":"Github项目目录中白色箭头怎么解决","slug":"其他/Github项目目录中白色箭头怎么解决","date":"2021-10-26T16:05:13.000Z","updated":"2022-02-12T12:18:15.682Z","comments":true,"path":"2021/10/27/其他/Github项目目录中白色箭头怎么解决/","link":"","permalink":"https://zhouyi.me/2021/10/27/%E5%85%B6%E4%BB%96/Github%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%99%BD%E8%89%B2%E7%AE%AD%E5%A4%B4%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/","excerpt":"如何解决github中文件夹出现白色箭头且无法打开。","text":"如何解决github中文件夹出现白色箭头且无法打开。 最近在弄博客的时候发现由于clone了pure的主题的仓库，个人做了些修改之后无法上传到github保存的问题。并且github目录中该目录图标会出现一个白色箭头，也无法打开。 箭头的意味是表示该模块是个嵌套的子模块。 解决方法如下： 删除该目录下的.git文件夹。 清除缓存git rm -r --cached [dir]，其中dir为文件夹名。 重新提交即可。","categories":[{"name":"tools","slug":"tools","permalink":"https://zhouyi.me/categories/tools/"}],"tags":[{"name":"git","slug":"git","permalink":"https://zhouyi.me/tags/git/"},{"name":"github","slug":"github","permalink":"https://zhouyi.me/tags/github/"}]},{"title":"二叉树遍历","slug":"数据结构与算法/二叉树遍历","date":"2021-10-25T04:12:22.000Z","updated":"2022-02-12T12:18:15.684Z","comments":true,"path":"2021/10/25/数据结构与算法/二叉树遍历/","link":"","permalink":"https://zhouyi.me/2021/10/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/","excerpt":"二叉树的前序遍历，中序遍历，后序遍历与层序遍历。","text":"二叉树的前序遍历，中序遍历，后序遍历与层序遍历。 目录 目录 概念 前序遍历 中序遍历 后序遍历 层序遍历 概念 前（根）序遍历 按照 根-&gt;左-&gt;右 的顺序进行遍历。 上图前序遍历结果：2 - 7 - 2 - 6 - 5 - 11 - 5 - 9 - 4 中（根）序遍历 按照 左-&gt;根-&gt;右 的顺序进行遍历。 上图中序遍历结果：2 - 7 - 5 - 6 - 11 - 2 - 5 - 4 - 9 后（根）序遍历 按照 左-&gt;右-&gt;根 的顺序进行遍历。 上图后序遍历结果：2 - 5 - 11 - 6 - 7 - 4 - 9 - 5 -2 层序遍历 按照层级进行遍历，类似于图的广度优先搜索 上图层序遍历结果：2 - 7 - 5 - 2 - 6 - 9 - 5 - 11 - 4 前序遍历 public void PreOrder(TreeNode node) &#123; if (node == null) &#123; return; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (node != null || !stack.isEmpty()) &#123; while (node != null) &#123; System.out.print(node.getVal()+\" \"); stack.push(node); node = node.getLeft(); &#125; if (!stack.isEmpty()) &#123; TreeNode pop = stack.pop(); node = pop.getRight(); &#125; &#125; &#125; 中序遍历 public void MidOrder(TreeNode node) &#123; if (node == null) &#123; return; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (node != null || !stack.isEmpty()) &#123; while (node != null) &#123; stack.push(node); node = node.getLeft(); &#125; if (!stack.isEmpty()) &#123; TreeNode pop = stack.pop(); System.out.print(pop.getVal()+\" \"); node = pop.getRight(); &#125; &#125; &#125; 后序遍历 public void PosOrder(TreeNode node) &#123; if (node == null) &#123; return; &#125; // 保存最后一个被访问的节点，用来判断节点的右子树是否被访问过 TreeNode lastVisitedNode = null; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (node != null || !stack.isEmpty()) &#123; while (node != null) &#123; stack.push(node); node = node.getLeft(); &#125; if (!stack.isEmpty()) &#123; // 一个节点可以访问的前提是自己没有右子树或者右子树被访问过 TreeNode pop = stack.pop(); if (pop.getRight() == null || pop.getRight() == lastVisitedNode) &#123; lastVisitedNode = pop; System.out.print(pop.getVal() + \" \"); &#125; else &#123; node = pop.getRight(); stack.push(pop); &#125; &#125; &#125; &#125; 层序遍历 public void LevOrder(TreeNode node) &#123; if (node == null) &#123; return; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(node); while (!queue.isEmpty()) &#123; TreeNode poll = queue.poll(); System.out.print(poll.getVal()+\" \"); if (poll.getLeft() != null) &#123; queue.offer(poll.getLeft()); &#125; if (poll.getRight() != null) &#123; queue.offer(poll.getRight()); &#125; &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://zhouyi.me/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://zhouyi.me/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"算法","slug":"算法","permalink":"https://zhouyi.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"面试准备","slug":"面试准备","date":"2021-10-25T04:01:06.000Z","updated":"2022-08-17T17:55:53.631Z","comments":true,"path":"2021/10/25/面试准备/","link":"","permalink":"https://zhouyi.me/2021/10/25/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/","excerpt":"个人面试准备的复习资料。","text":"个人面试准备的复习资料。 目录 目录 Java基础 Mysql 计算机网络和操作系统 数据结构与算法 设计模式 Redis Spring相关 个人项目笔记 Java基础 Java基础 JVM 多线程 Java集合容器 Java反射注解泛型 Mysql mysql应用篇 mysql原理篇 计算机网络和操作系统 计算机网络 操作系统 数据结构与算法 数据结构 排序算法 二叉树遍历 设计模式 单例模式 工厂模式 代理模式 Redis Redis知识复习 Spring相关 Spring SpringBoot Mybatis 个人项目笔记 论坛管理项目 Spring容器项目","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouyi.me/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouyi.me/tags/Java/"},{"name":"面试","slug":"面试","permalink":"https://zhouyi.me/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"关于个人博客评论系统gitalk的一些错误","slug":"博客相关/关于个人博客评论系统gitalk的一些错误","date":"2021-10-24T18:24:16.000Z","updated":"2022-02-12T12:18:15.683Z","comments":true,"path":"2021/10/25/博客相关/关于个人博客评论系统gitalk的一些错误/","link":"","permalink":"https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%85%B3%E4%BA%8E%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9Fgitalk%E7%9A%84%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF/","excerpt":"","text":"","categories":[{"name":"博客","slug":"博客","permalink":"https://zhouyi.me/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://zhouyi.me/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"将github.io个人博客网址收录到搜索引擎","slug":"博客相关/将github-io个人博客网址收录到搜索引擎","date":"2021-10-24T18:22:33.000Z","updated":"2022-02-12T12:18:15.683Z","comments":true,"path":"2021/10/25/博客相关/将github-io个人博客网址收录到搜索引擎/","link":"","permalink":"https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%B0%86github-io%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E5%9D%80%E6%94%B6%E5%BD%95%E5%88%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/","excerpt":"此博客记录如何将github.io的博客提交到搜索引擎中收录。","text":"此博客记录如何将github.io的博客提交到搜索引擎中收录。 目录 目录 查看网站是否被收录 生成站点地图 添加到Google 添加到Bing 添加到Baidu Baidu主动提交 查看网站是否被收录 在搜索引擎输入以下命令进行搜索。 site:zhouyi.me 出现如下回应则表示被收录的，否则就是没有 生成站点地图 hexo是有生成站点地图的插件的，输入以下命令进行安装。 npm install hexo-generator-sitemap 之后每次生成静态文件的时候目录下就会有站点地图文件sitemap.xml。 添加到Google 登录google search console。 添加站点资源，在网址前缀类型中输入网址。 之后需要进行验证，验证方法有以下几种。 如果采用html文件验证的话，如果采用hexo则需要设置不针对此文件进行生成静态文件，这里可以自行查看官方网站配置说明。 不设置好的话，html文件会套用主题模板变成一个博客主题页面。 个人没有详细去看，觉得比较麻烦，就直接采用了第二种HTML标记验证法，即在模板文件的&lt;head&gt;标签加入指定&lt;meta&gt;元素即可，这个可能根据主题不同而不同，pure主题则是更改pure/layout/_common/head.ejs模板文件，其他主题原理应该差不多。 之后提交站点地图即可。根据hexo插件自动生成，文件名为sitemap.xml。 添加到Bing 登录Bing的webmaster控制台。 添加站点资源。 之后进行验证。 第一种方法，将给出的xml文件放入项目目录中，和CNAME文件一样，由于每次都会生成静态文件，直接添加到源文件CNAME同级目录下即可，即source目录下。 第二种方法，和添加到Google的方法一样，添加&lt;meta&gt;元素。 之后添加站点地图。根据hexo插件自动生成，文件名为sitemap.xml。 添加到Baidu 百度则相对比较麻烦一点。 首先登陆到站点管理控制台 添加站点资源。 之后进行验证。 如果采用第二种方法，和添加到Google的方法一样，添加&lt;meta&gt;元素。 之后进行提交站点地图。 百度有专门的站点地图，我也不知道为啥，看了一眼生成的文件其实差不多。输入以下命令安装插件，之后生成静态文件的时候会在sitemap.xml同级目录下生成baidusitemap.xml。我们直接两个都提交。 npm install hexo-generator-baidu-sitemap 由于Baidu爬虫有无法爬取Github pages的错误，需要各种手段解决，最近看到这一篇文章算是比较好的解决方案，下面是大佬的博客链接： 解决百度爬虫无法爬取 Github Pages 个人博客的问题 Baidu主动提交 除了提交sitemap，我们也可以主动提交。 首先，输入以下命令安装插件 npm install hexo-baidu-url-submit 之后在_config.yml文件添加如下配置，如下： baidu_url_submit: count: 30 // 提交最新的多少链接 host: https://zhouyi.me // 添加的域名 token: xxxxxx // 上图中的token path: baidu_urls.txt // 另外添加一行 type: baidu_url_submitter 注意在两个type前加上 - deploy: - type: git repo: https://github.com/blue-zy/blue-zy.github.io.git - type: baidu_url_submitter 之后进行部署 hexo clean hexo g hexo d 根据api提交反馈信息 若输出如下形式，则表示推送成功 &#123;&quot;remain&quot;:2988,&quot;success&quot;:12&#125; INFO Deploy done: baidu_url_submitter","categories":[{"name":"博客","slug":"博客","permalink":"https://zhouyi.me/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://zhouyi.me/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"数据结构","slug":"数据结构与算法/常见数据结构","date":"2021-10-24T18:00:53.000Z","updated":"2022-02-12T12:18:15.684Z","comments":true,"path":"2021/10/25/数据结构与算法/常见数据结构/","link":"","permalink":"https://zhouyi.me/2021/10/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"此文介绍常见的数据结构","text":"此文介绍常见的数据结构 目录 目录 什么是数据结构 常见的数据结构 线性表 栈和队列 栈 队列 串 数组和广义表 数组 广义表 树和二叉树 树 二叉树 图 哈希表 什么是数据结构 基本概念和术语 数据 是对客观事物的符号表示，在计算机科学中，含义非常广泛，如图像，声音等都可以通过编码归类于数据的范畴。 数据元素 是数据的基本单位，在程序中通常作为一个整体，而一个数据元素又有可能含有多个数据项，数据项是不可分割的最小单位。 数据对象 性质相同的数据元素的集合，数据的子集，比如整数数据对象（集），字符数据对象（集）。 数据结构 是相互之间存在一种或者多种特定关系的数据元素的集合。 数据元素相互之间的关系称为结构，常见的关系有： 集合：除了同属于一个集合外别无其他关系。如公司的员工名单表，无其他信息。 线性结构：数据元素存在一个对一个的关系。如公司的员工名单带有工号按一定顺序排序。 树形结构：数据元素存在一个对多个的关系。如公司的员工之间存在上下级关系，一个上级有多个下级。 图状结构/网状结构：数据元素存在多个对多个的关系。如公司之间各个部门的协作关系。 上述所说的数据结构实则是数据元素之间的逻辑关系，即逻辑结构。 数据结构在计算机中的表示（映像）称为数据的物理结构，也称为存储结构。 顺序映像对应顺序存储结构，根据相对位置。 非顺序映像对应链式存储结构，根据指针。 常见的数据结构 线性表 栈和队列 串 数组和广义表 树和二叉树 图 哈希表 线性表 线性表是一种线性结构，线性结构的特点是： 存在唯一一个被称为“第一个”的数据元素 存在唯一一个被称为“最后一个”的数据元素 除了第一个之外，每个数据元素均只有一个前驱 除了最后一个之外，每个数据元素均只有一个后继 线性表中存储的数据类型必须一致。 两种存储结构： 顺序存储结构 顺序表，用一组地址连续的存储单元一次存储线性表的数据元素。 链式存储结构 链表，用一组任意的存储单元存储线性表的数据元素。除了存储本身的信息之外，还需要存储一个指示其直接后继的信息。 指针域 数据域 另外两种形式的链式存储结构： 循环链表 双向链表 栈和队列 栈 定义：栈是限定仅在表尾进行插入或者删除操作的线性表，即FILO。 栈顶：表尾 栈底：表头 两种存储表示方法： 顺序栈：利用一组地址连续的存储单元一次存放自栈底到栈顶元素。 链栈：利用链表实现栈的存储结构。 队列 定义：队列是一种符合FIFO原则的线性表。 队头：只允许删除元素。 队尾：只允许插入元素。 两种存储表示方法： 顺序队列：地址连续的存储单元。 链队列：利用链表实现。 另两种数据结构： 双端队列 循环队列 串 定义：串（或字符串）是有零个或者多个字符组成的有限序列。 串的逻辑结构和线性表极为相似，区别仅在于传中的数据对象约束为字符集。 三种存储表示方法： 定长顺序存储 类似线性表的顺序存储结构，地址连续的存储单元。分配定长，超长部分会被截断。 堆分配存储表示 地址连续，但存储空间是程序执行中动态分配的。如C语言中，存在一个自由存储去称为“堆”，可以由malloc()和free()管理。 块链存储表示 和链表类似，但每个节点可以存储一个字符，也可以存储多个字符，因此最后一个结点不一定全被串值占满，通常会补上其他非串值字符如#。 存储密度 = 串值所占存储位/实际分配存储位 串的模式匹配算法和KMP算法 参考字符串相关算法 数组和广义表 数组 线性表讨论的都是数据元素不可再分的情况，而数组可以存储本身也是一种数据结构的数据元素。 如二维数组，可以看成一个线性表中存储的元素是数组。 但是数据类型必须一致。 数组结构通常使用顺序存储结构，通常只做查找和修改操作，而插入和删除操作效率是很差的。 广义表 数组可以存储不可再分的数据元素，也可以存储数组，但是数据类型必须一致，而广义表去掉了这种限制。 广义表又称列表，也是一种线性存储结构，广义表中既可以存储不可再分元素，也可以存储广义表。 广义表通常使用链表实现，因为里面存储的元素种类不一，顺序表比较难以处理。 树和二叉树 树 定义：树是n个结点的有限集，任意一棵非空树中： 有且仅有一个根节点 当n&gt;1时，其余结点又可分为m(m&gt;0)个互不相交的有限集，而它们也是树，称为根节点的子树 术语： 结点的度：结点拥有的子树数量 叶子结点/终端结点 分支结点/非终端结点 双亲 孩子 兄弟：同一个双亲结点的孩子们 祖先：从根结点到该结点的所有结点 子孙：以该结点为根的子树的任一结点 层次：根为第一层，根的孩子为第二层，以此类推 堂兄弟：双亲结点在同一层的结点 深度：最大层次称为树的深度 森林：不相交的树 二叉树 定义：每个结点至多只有两个子树的树，且子树有左右之分。 性质： 第i层上至多有2^(i-1)个结点。 深度为k的二叉树至多有2^k - 1个结点。 若终端结点数为n0，度为2的结点数为n2，则n0=n2+1。 具有n个结点的完全二叉树深度为log2(n)+1。 略。 二叉树的存储结构 顺序存储结构 通过添加一些额外结点，将树构建成一棵完全二叉树，按照层次（从上往下，从左往右）顺序存储。 链式存储结构 包含三个域，有时还多出一个指向双亲结点的指针域 数据域 左子树，指针 右子树，指针 二叉树的遍历 先序遍历：根 – 左 – 右 中序遍历：左 – 根 – 右 后序遍历：左 – 右 – 根 层次遍历：从上往下，从左往右。 详情参考此篇文章。 线索二叉树（对于链式存储） 概念：若结点有左子树，lchild指向左子树，否则指向前驱，若结点有右子树，rchild指向右子树，否则指向后继。 新增两个标志位LTag和RTag，分别代表有无左右子树。 以上述结点结构构成的二叉树的存储结构，称为线索链表，指向前驱和后继的指针称为线索，加上线索的二叉树称为线索二叉树。 另外， 给出先序遍历和后序遍历，不能唯一确定一棵二叉树。因为先序和后序只是反映了结点间的父子关系，没有反映出左右关系。 给出先序遍历或者后序遍历，再给出中序遍历，能够唯一确定一棵二叉树。 特殊的二叉树 满二叉树：深度为k时，结点数量为2^k - 1。 完全二叉树：深度为k时，所有结点的编号与深度为k的满二叉树一一对应。 路径：一个结点到另一个结点的途径。 路径长度：路径上的分支数目，即每经过一个结点长度加1。 树的路径长度：树根到每一个结点的路径长度之和。 完全二叉树就是路径长度最短的二叉树。 最优二叉树 结点带权路径：该结点到树根之间的路径长度与结点的权值乘积。 树的带权路径长度：树中所有叶子结点的带权路径长度之和。 带权路径长度WPL最小的二叉树即为最优二叉树/赫夫曼树。 赫夫曼算法：用来构建赫夫曼树 根据给定的n个权值构成n棵二叉树集合F，其中每棵二叉树中只有一个带权的根结点，无子树。 从F中选出两棵根结点权值最小的树，作为左右子树构建一棵新二叉树，新二叉树的根权值为这俩之和。 将新二叉树加入到F中，移除第二步的两个二叉树。 重复2和3。 赫夫曼编码： 对于设计长度不等的编码的情况，必须要任一个字符的编码都不是另一个字符的编码的前缀，这种编码称为前缀编码。 利用赫夫曼树进行编码如下图所示。 编码结果： 字符 编码 a1 0 a2 10 a3 110 a4 111 https://www.jianshu.com/p/ebbae6e80273（各种特殊树总结） 二叉排序树 平衡二叉树，自平衡二叉树-AVL https://zhuanlan.zhihu.com/p/56066942 （平衡二叉树及旋转之类的） 红黑树 B树 B+树 B*树 回溯法 互换 递归 换回来 图 定义：图形之中，结点之间的关系是任意的，任何两个结点都有可能相关。 术语： 顶点V：数据元素 弧，弧头，弧尾：有向图中一个顶点到另一个顶点的表示 若弧是无序的，则为无向图，此时可称为边 完全图：不考虑顶点到自身的边的话，n个结点有n(n-1)/2条边 有向完全图：不考虑顶点到自身的弧的话，n个结点有n(n-1)条弧 稀疏图：边少的图，比如边&lt;nlogn 稠密图 子图 邻接点：无向图中有边连接的两个顶点，称这条边与这两个顶点相关联 顶点的度：和顶点相关联的边的数目 入度：以顶点为头的弧的数量 出度：以顶点为尾的弧的数量 路径：顶点序列 回路/环：第一个顶点和最后一个顶点相同的路径 简单路径：序列中顶点不重复的路径 简单回路/简单环：除了第一个顶点和最后一个顶点，序列中顶点不重复的回路 连通：顶点之间有路径 连通图：任意两个顶点都有路径 连通分量：无向图中的极大连通子图 强连通图：每一对结点都有两条路径，因为有向，所以这里的两条路径是反向的（但不一定要相同结点序列） 强连通分量：有向图中极大强连通分量 连通图的生成树：极小连通子图，含有图中全部结点，只有足以构成一棵树的n-1条边 图的存储结构： 无顺序映像存储结构，但是可以借助数组来表示元素之间的关系。 多重链表，邻接表，邻接多重表，十字链表。 图的遍历： 深度优先搜索：类似树的先序遍历 广度优先搜索：类似树的按层次遍历 图的连通性问题： 哈希表 定义： https://blog.csdn.net/qq_29462849/article/details/88930870 哈希函数的构造方法： 直接定址法 数字分析法 平方取中法 折叠法 除留余数法 处理哈希冲突的方法： 开放定址法 线性探测 再哈希法 链地址法 建立公共溢出区","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhouyi.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhouyi.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"将Github.io绑定到Godaddy域名","slug":"博客相关/将Github-io绑定到Godaddy域名","date":"2021-10-24T16:55:38.000Z","updated":"2022-02-12T12:18:15.683Z","comments":true,"path":"2021/10/25/博客相关/将Github-io绑定到Godaddy域名/","link":"","permalink":"https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%B0%86Github-io%E7%BB%91%E5%AE%9A%E5%88%B0Godaddy%E5%9F%9F%E5%90%8D/","excerpt":"此文章介绍如何绑定github pages到个性域名。","text":"此文章介绍如何绑定github pages到个性域名。 目录 目录 域名购买 设置dns域名解析 github pages设置和项目设置 域名购买 本文以Godaddy为例说明。 直接在输入框输入想要注册的域名。 拿下，接着跳转到付款页面。 全选No Thanks，继续。 付款页面支持Alipay，这点还是挺方便的。 设置dns域名解析 我们不用自带的域名解析，直接用DNSPOD解析。 首先我们先看看github.io的IP地址，直接ping或者nslookup也行。 ping username.github.io // username为个人用户名 nslookup username.github.io // username为个人用户名 基本上是四个，而ping出来的就一个，那么我们待会就设置ping出来的这个就好了，假设为185.199.111.153。 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 登录DNSPOD之后，进入控制台的DNS解析，添加记录。 其实就添加两条 主机记录：@ 记录类型：A 主机记录：www 记录类型：CNAME 另外，我们将默认的两个记录值记下，需要在Goddy中配置。注意不需要.。 concrete.dnspod.net poult.dnspod.net 登录Goddy之后，右上角进入My Product选择域名的DNS settings，设置成以下的即可。 github pages设置和项目设置 之后我们向github.io项目中添加一个名为CNAME(大写) 的文件，里面只包含顶级域名，如下： zhouyi.me 之后，从项目的setting中进入github pages的设置页，如下设置即可。 另外，如果我们用hexo部署的话，每次都会重新生成静态文件，因此我们需要直接将CNAME文件放入部署博客的源码中的source目录下，这样每次生成静态文件就会带上此目录的CNAME文件。 最后，记得更改项目中的_config.yml设置文件。 url: https://zhouyi.me/ 有些插件如生成sitemap的插件是根据此来生成的，关于如何生成站点地图以及提交网址到搜索引擎请参考此链接。","categories":[{"name":"博客","slug":"博客","permalink":"https://zhouyi.me/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://zhouyi.me/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"利用Hexo和Github.io搭建静态博客","slug":"博客相关/利用Hexo和Github-io搭建静态博客","date":"2021-10-24T16:45:38.000Z","updated":"2022-02-12T12:18:15.683Z","comments":true,"path":"2021/10/25/博客相关/利用Hexo和Github-io搭建静态博客/","link":"","permalink":"https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%88%A9%E7%94%A8Hexo%E5%92%8CGithub-io%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/","excerpt":"此博客介绍如何将Hexo部署到Github pages上。","text":"此博客介绍如何将Hexo部署到Github pages上。 目录 目录 安装nodejs 安装hexo 设置Github pages 部署hexo 备份博客 安装nodejs 首先下载Node.js安装程序，Windows用户请确保勾选Add to PATH选项。 如果没有勾选此选项需要手动添加Node.js到环境变量。手动添加的步骤如下： 右键点击此电脑，选择属性 -&gt; 高级系统设置 -&gt; 环境变量 双击系统变量中的的path点击新建 输入安装Node.js的路劲，即npm.cmd和npx.cmd所在文件夹 安装hexo 输入win+r输入cmd，在命令提示符中输入npm i -g hexo-cli安装hexo。 输入hexo -v出现hexo版本信息表示安装成功。 设置Github pages 首先在github中新建一个项目，项目名为username.github.io，username为你的github账户名。 接着点击setting，往下直到github pages部分，点进去。 Pages settings now has its own dedicated tab! Check it out here! 浏览器输入 https://zhouzhou84751.github.io/ 即可以进入自己的github pages。 接着关联本地的git和github。 打开命令提示符输入以下命令。 git config --global user.name &quot;username&quot; // username根据自己的github账号填入 git config --global user.email &quot;xxx@xxx.com&quot; // email根据自己的github账号填入 ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot; // email根据自己的github账号填入 一路回车即可 // ssh密钥默认生成在~/.ssh/id_rsa.pub cat ~/.ssh/id_rsa.pub // windows目录下直接拷贝也行 // 默认目录如下 C:\\Users\\你的用户名\\.ssh\\id_rsa.pub，直接用编辑器打开复制下来 接着在github页面右上角的用户名中点击Settings，选择左侧SSH and GPG keys，New一个SSH key。 Title随便填，Key粘贴刚刚复制的内容。 此时命令提示符输入如下命令会提示添加成功。 ssh -T git@github.com Hi zhouzhou84751! You've successfully authenticated, but GitHub does not provide shell access. 部署hexo 在本地选择一个你喜欢的文件夹目录，初始化hexo。 在命令行输入以下命令初始化。 hexo init myblog // 初始化 hexo s // 部署在本地服务器 默认端口为4000 接着打开浏览器输入localhost:4000，出现如下页面则表示部署成功。 部分的目录结构如下： // 模板目录 如输入hexo n post hello时会以此目录下的post.md为模板在source/_posts新建hello.md - scaffolds // 博文目录 - source/_posts // 配置文件 - _config.yml // 主题文件夹 - themes 常用的几个命令如下： // []表示可以省略的内容 &lt;&gt;表示变量名，即输入的参数 // 新建文章，未指定layout则默认使用_config.yml中的default_layout参数的layout hexo n [layout] &lt;title&gt; // 清除缓存文件和生成静态文件，常在做了大改动的情况下使用，否则网站有可能会改动不生效 hexo clean // 生成静态文件，部署到github前记得调用 hexo g // 启动服务器，通常是部署到本地给自己看的 hexo s // 部署网站，即部署到github hexo d 更改配置文件_config.yml。 title: my blog // 网站标题 author: zhouzhou84751 // 作者 language: zh-CN // 语言 url: https://zhouzhou84751.github.io/ // github pages的url，如果自定义域名也需要更改 theme: landscape // 主题设置 deploy: type: 'git' repo: git@github.com:zhouzhou84751/zhouzhou84751.github.io.git // 项目地址，推荐填入ssh的地址 branch: main // 项目分支 默认是main 基础配置完毕后，安装hexo-deployer-git插件。更多说明请参照hexo官方文档。 npm install hexo-deployer-git --save 部署到github pages。 hexo clean hexo g hexo d 每次部署最好都执行clean和generate命令，这样每次输入三个命令太麻烦了，我们可以添加到hexo项目中的package.json中scripts中，新建一个upload变量如下所示。 &quot;scripts&quot;: &#123; // 默认命令 &quot;build&quot;: &quot;hexo generate&quot;, &quot;clean&quot;: &quot;hexo clean&quot;, &quot;deploy&quot;: &quot;hexo deploy&quot;, &quot;server&quot;: &quot;hexo server&quot;, // 新建一个upload 注意上面加一个, &quot;upload&quot;: &quot;hexo clean&amp;&amp;hexo generate&amp;&amp;hexo deploy&quot; &#125;, 这样每次运行以下命令就可以直接一键三连部署。 npm run upload 备份博客 虽然我们将hexo博客部署到github.io项目上面，但是我们用来部署的源码依旧在本地，因此推荐新建一个私人仓库上传hexo项目，因为源码中的设置涉及到很多token之类的信息，最好不要设为公开项目。","categories":[{"name":"博客","slug":"博客","permalink":"https://zhouyi.me/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://zhouyi.me/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"排序算法","slug":"数据结构与算法/排序算法","date":"2021-10-24T05:54:59.000Z","updated":"2022-02-12T12:18:15.685Z","comments":true,"path":"2021/10/24/数据结构与算法/排序算法/","link":"","permalink":"https://zhouyi.me/2021/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"此文介绍常见的排序算法。","text":"此文介绍常见的排序算法。 目录 目录 常见排序算法 冒泡排序 选择排序 简单插入排序 希尔排序 归并排序 快速排序 堆排序 排序算法比较 常见排序算法 冒泡排序 选择排序 简单插入排序 希尔排序 归并排序 快速排序 堆排序 本文中图来自于菜鸟教程的十大经典排序。 冒泡排序 顾名思义，冒泡排序就是两两比较，将最大的放在最底下，利用如同冒泡一样将元素上升的方法。 由于比较基础也比较容易理解，直接上代码。 public void sort(int[] arr) &#123; boolean isSort = false; // 增加标志位，如果一个循环里没有发生数据交换，则证明已经排序好了 for (int i = 0; i &lt; arr.length &amp;&amp; !isSort; i++) &#123; // 每次让最大的泡泡升出来 isSort = true; for (int j = 1; j &lt; arr.length - i; j++) &#123; if (arr[j-1] &gt; arr[j]) &#123; int temp = arr[j-1]; arr[j-1] = arr[j]; arr[j] = temp; isSort = false; &#125; &#125; &#125; &#125; 时间复杂度 最好情况是O(n)，排序好了的情况，此时只比较但不用交换。 最坏情况都没排序好，此时经过(n-1)+(n-2)+...+1 = n(n-1)/2次比较，时间复杂度为O(n^2)。 平均时间复杂度为O(n^2)。 空间复杂度 不需要借助额外的开辟新数组的空间，为O(1)。 选择排序 类似打擂台的方法，每次循环选出一个值跟所有值比较，最后最小值胜出。 也比较容易理解，直接上代码。 public static void sort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; // 选出最小值的索引 for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j]&lt;arr[minIndex]) &#123; minIndex = j; &#125; &#125; // 交换最小值到“擂台” if (minIndex != i) &#123; int temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; &#125; &#125; 时间复杂度 最好最坏情况都需要进行n(n-1)/2次比较，时间复杂度为O(n^2)。 空间复杂度 不需要借助额外的开辟新数组的空间，为O(1)。 简单插入排序 两两比较，比较的过程中，元素一直往后移。 结合动图理解起来也比较直观，上代码。 public static void sort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[j]; // 先把要插入的数挖出来 // 当要插入的数比前一个数小的时候，前面元素往后移 while (j &gt; 0 &amp;&amp; temp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; j--; &#125; arr[j] = temp; &#125; &#125; 时间复杂度 最好情况仅需要经过n-1次比较，不需要交换，为O(n)。 最坏情况为O(n^2)。 空间复杂度 不需要借助额外的开辟新数组的空间，为O(1)。 希尔排序 希尔排序是插入排序的一种优化方案，插入排序中的元素后移比价浪费时间，因为每次都只能移动一个位置交换相邻的元素。 希尔排序通过设置一个增量值即间隔，直接根据增量来达到交换不相邻的元素，每次可以将逆序数数量减少大于1。 如3,2,1有两个逆序对，若通过简单插入排序，一次只能消除一个逆序对。通过希尔排序则可以让3和1直接交换，达到消除多对逆序对的效果。 另外，简单插入排序对于数组部分有序的逆序对较少的情况，时间复杂度也比较低。 综合上述，首先大幅度减少逆序对，之后再不断减少增量值，最后便转化为简单插入排序，此时已经部分有序，所以效果比直接用插入排序算法要好得多。 public void sort(int[] arr) &#123; // 在此我们将增量设置为length/2 每次缩小一半 for (int step = arr.length/2; step &gt;0 ; step/=2) &#123; for (int i = step; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[j]; while (j &gt;= step &amp;&amp; temp &lt; arr[j - step]) &#123; int t = arr[j]; arr[j] = arr[j - step]; arr[j - step] = t; j -= step; System.out.println(Arrays.toString(arr)); &#125; arr[j] = temp; &#125; &#125; &#125; 时间复杂度 据说是1959年Shell发明的，第一个突破O(n^2)的排序算法。 复杂度难以分析，所以在此省略分析过程，平均复杂度为O(nlogn)。 空间复杂度 不需要借助额外的开辟新数组的空间，为O(1)。 归并排序 归并排序主要采用了分治和递归的思想。如上图所示，二路归并是将数据平分成两组各自进行排序，之后再将这两组排序的结果再进行排序，一直递归调用。 代码如下： public void sort(int[] arr, int left, int right)&#123; if(left&lt;right)&#123; int middle = (left + right)/2; sort(arr, left, middle); sort(arr, middle+1, right); merge(arr, left, right); &#125; &#125; public void merge(int[] arr, int left, int right)&#123; int middle = (left + right)/2; // 开辟一个新数组用来存储排序后的结果 int[] temp = new int[right - left + 1]; int i = left; int j = middle + 1; int t = 0; while(i &lt;= middle &amp;&amp; j&lt;=right)&#123; if(arr[i] &lt; arr[j])&#123; temp[t++] = arr[i++]; &#125;else&#123; temp[t++] = arr[j++]; &#125; &#125; while(i&lt;=middle)&#123; temp[t++] = arr[i++]; &#125; while(j&lt;=right)&#123; temp[t++] = arr[j++]; &#125; // 记得将数组内容赋值回原数组 t = 0; while(left&lt;=right)&#123; arr[left++] = temp[t++]; &#125; &#125; 时间复杂度 和选择排序一样，归并排序的性能并不受输入数据的影响，但是表现却要比选择排序优秀得多。 归并排序是一种十分高效的稳定的排序，可以看到每次合并的操作时间复杂度为O(n)，而完全二叉树的深度为log2n，因此总的来说，归并算法的时间复杂度为O(nlogn)，并且永远是O(nlogn)。 空间复杂度 归并排序的代价就是需要额外的内存空间，必须新开辟一块内存空间用来暂存合并之后的数组。因此空间复杂度为O(n)。 快速排序 如果说归并排序是先局部有序，然后整体有序，那么快速排序正好相反，快速排序可以理解为先整体有序，再局部有序。 具体的排序思想是，先找出一个基准(pivot)，之后将比基准大的值放在基准的后面，而小的值放在前面，也就是说，每次的排序相当于将这个基准值归位。 之后再递归地将基准左右的值进行快速排序。 代码如下： public void sort(int[] arr, int left, int right)&#123; if(left&lt;right)&#123; int pivot = arr[left]; int i = left; int j = right; while(i &lt; j)&#123; // 从右开始往左寻找第一个比基准小的值 while(i &lt; j &amp;&amp; arr[j] &gt; pivot)&#123; j--; &#125; // 放入左边的坑中，此时j的位置相当于一个坑 if(i &lt; j)&#123; arr[i] = arr[j]; i++; &#125; // 从左往右开始寻找第一个比基准大的值 while(i &lt; j &amp;&amp; arr[i] &lt; pivot)&#123; i++; &#125; // 放入右边的坑中 if(i &lt; j)&#123; arr[j] = arr[i]; j--; &#125; &#125; // 此时i和j相等，将基准放入这个坑中 arr[i] = pivot; sort(arr, left, i-1); sort(arr, i+1, right); &#125; &#125; 时间复杂度 快速排序的最坏情况是O(n^2)，当数组有序的时候（所有元素都相同），不论正序倒序，就会出现循环了两次。 解决方法是随机选择pivot或者随机打乱数组。 最好的情况是每次都正好对半分，如同归并算法一样像个完全二叉树一样，这样时间复杂度为O(nlogn)。 平均时间复杂度为O(nlogn)。 空间复杂度 快速排序是在原本的数组基础上排序的，无需辅助数组，但是递归调用需要辅助栈。 最坏情况为O(n)。递归了n次。 最好的情况为O(logn)。 堆排序 两个概念： 大顶堆：每个节点都大于或者等于其子节点的值，堆排序中用于升序排列。 小顶堆：每个节点都小于或者等于其子节点的值，堆排序中用于降序排列。 完全二叉树：结点按照从上往下从左往右编号一一对应同样深度的满二叉树的对应位置的编号的二叉树。 满二叉树：深度为k时，有2^k - 1个结点的二叉树。 由于完全二叉树可以用编号对应结点的，因此数组中的index可以对应成一个完全二叉树的结点编号，因此我们可以将数组看成完全二叉树来处理。 假设根节点编号为0，二叉树中的孩子结点与双亲结点的编号关系： left = root*2 + 1; right = root*2 + 2; parent = (root - 1)/2; 根据上述关系，就可以将数组看成二叉树，进而转换成堆来进行排序。 步骤如下： 构建大顶堆 将大顶堆的根结点与最后一个叶结点位置互换，去除叶结点 对去除最后一个结点的完全二叉树进行heapify操作 goto 步骤2 public void sort(int[] nums)&#123; buildHeap(nums); for (int i = nums.length - 1; i &gt; 0; i--) &#123; // 将叶结点和根结点互换，并去除叶结点再堆化 int temp = nums[i]; nums[i] = nums[0]; nums[0] = temp; // i-1 代表去除了叶结点 heapify(nums,0,i-1); &#125; &#125; // 构建大顶堆 public void buildHeap(int[] nums) &#123; int len = nums.length-1; for (int i = (len-1)/2; i &gt;= 0; i--) &#123; heapify(nums,i,len); &#125; &#125; // 堆化操作 public void heapify(int[] nums, int start, int end)&#123; int lastRootIndex = start; int max = lastRootIndex; int left = 2*lastRootIndex + 1; int right = 2*lastRootIndex + 2; if (left&lt;=end &amp;&amp; nums[left]&gt;nums[max])&#123; max = left; &#125; if (right&lt;=end &amp;&amp; nums[right]&gt;nums[max])&#123; max = right; &#125; if (max != lastRootIndex) &#123; int temp = nums[max]; nums[max] = nums[lastRootIndex]; nums[lastRootIndex] = temp; heapify(nums,max,end); &#125; &#125; 排序算法比较 归并排序VS快速排序 快速排序不稳定，归并排序是稳定的，能够保证原来的顺序。 归并排序需要借助额外的空间，不是原地排序算法。","categories":[{"name":"算法","slug":"算法","permalink":"https://zhouyi.me/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhouyi.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://zhouyi.me/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"博客搭建相关","slug":"博客相关/博客搭建相关","date":"2021-09-23T16:00:00.000Z","updated":"2022-02-12T12:18:15.683Z","comments":true,"path":"2021/09/24/博客相关/博客搭建相关/","link":"","permalink":"https://zhouyi.me/2021/09/24/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/","excerpt":"此博客是根据github.io和hexo结合的方案搭建的静态个人博客，本文主要记录一下搭建过程中遇到的问题。","text":"此博客是根据github.io和hexo结合的方案搭建的静态个人博客，本文主要记录一下搭建过程中遇到的问题。 Hexo和Github pages 关于如何将hexo部署到github pages请参考下面的教程。 利用Hexo和Github.io搭建静态博客 pure主题皮肤相关 hexo支持设置自己喜欢的主题，可以从此网站挑选大佬们做好的模板。 此博客采用的皮肤为pure。 另外，由于原作者暂时没有时间维护，有大佬出了一个保姆级魔改教程。 里面关于皮肤的许多扩展改进进行了详细的说明，有需要的可以根据个人进行改动，注意是仅针对pure主题的。 关于评论系统gitalk 此博客采用的评论系统为gitalk，gitalk相关问题可以查看此篇博客： 关于个人博客评论系统gitalk的一些错误 绑定自定义域名和域名解析 搭建好github pages还可以绑定自定义的域名。可以参考下面的教程。 将Github.io绑定到Godaddy域名 将网址收录到搜索引擎 至此，博客已经搭建完成，最后为了能够在搜索引擎中搜索到个人博客，我们需要将网址收录到各个搜索引擎。 将github.io个人博客网址收录到搜索引擎","categories":[{"name":"博客","slug":"博客","permalink":"https://zhouyi.me/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://zhouyi.me/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"递归算法学习","slug":"数据结构与算法/递归算法学习","date":"2021-08-15T05:51:46.000Z","updated":"2022-02-12T12:18:15.685Z","comments":true,"path":"2021/08/15/数据结构与算法/递归算法学习/","link":"","permalink":"https://zhouyi.me/2021/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/","excerpt":"从一个反转链表的算法题来学习递归算法。","text":"从一个反转链表的算法题来学习递归算法。 介绍 递归算法在编程中运用广泛，递归算法一般指的是在函数内部通过不断调用自身求解的一种方法。以一个求阶乘的函数举例，则如以下形式(n&gt;=1)： test public static int func(int n)&#123; if (n == 1)&#123; return n; &#125; int temp = func(n-1); int res = n * temp; return res; &#125; 这是一个简单的递归的函数，结果res为n乘以n-1的阶乘，一直往下推，推到最后n为1的时候则开始返回。 一般情况 那么如何思考递归的过程比较好呢？可以从以下的一种形式分析： func(param1)&#123; // 调用自身的终止条件 if (endCondition) &#123; return; &#125; value = func(param2); // 此处调用自身 &#125; 函数的其余部分则视情况加入逻辑处理的部分。 首先我们考虑终止情况，是有个确定的返回值的，接着再往上走，只需记住一点，函数中调用自身之后返回的是已经处理好了的之前的结果。 比如阶乘算法中，n*temp，此时temp的结果就是计算好了的n-1的阶乘。 这样去思考，则思路会清晰很多。 反转链表 以一道简单的反转链表的问题举例，题目如下： 输入一个单链表的表头，返回一个反转之后的链表的表头。 如输入&#123; 1-&gt; 2 -&gt; 3&#125;， 返回&#123; 3 -&gt; 2 -&gt; 1&#125; 这道题很容易想到可以用入栈出栈的方法去做，当然也可以用递归的方法做。代码如下： public static ListNode reverse(ListNode head)&#123; if( head.next == null )&#123; return head; &#125; ListNode res = reverse(head.next); // 此时res为处理好了的，即已经表头为head.next反转过后的结果 // 注意此时返回的表尾部是head.next, 因此我们要对接尾部和head自身 head.next.next = head; head.next = null; return res; &#125; 这是从尾部开始递归的情况，当然从头部开始递归也行。代码如下： public static ListNode reverse(ListNode head)&#123; // 从头部开始递归，那么头部的下一个节点结果是null，因此可以如下设计 ListNode res = func (head, null); return res; &#125; public static func(ListNode head, ListNode node)&#123; // head为头部，node为head指向的下一个节点 if (head == null)&#123; return node; &#125; ListNode tmp = head.next; head.next = node; ListNode res = func(tmp, head); return res; &#125; 这是从头部开始递归的，首先处理好头部然后再处理后面的，此时要注意一下终止条件，如果我们将终止条件设置为如下： if (head.next == null)&#123; return head; &#125; 则会出现结果返回只有一个尾部节点的情况。这是因为如果从头部开始递归的话，则需要注意，逻辑处理的部分是在判断终止条件之后执行的，正好跟尾递归相反，即使轮到自身节点是，已经处理好了自身之前的节点，自身则需要和处理好的节点对接，因此我们如果将终止条件的“自身节点”设置为尾部的next，即为null，则说明已经处理好了尾部及尾部之前的节点，返回值不会出错。 最后，如有错误，欢迎指正，虚心学习。","categories":[{"name":"算法","slug":"算法","permalink":"https://zhouyi.me/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouyi.me/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://zhouyi.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"编程","slug":"编程","permalink":"https://zhouyi.me/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"test","slug":"其他/test","date":"2021-08-13T18:09:05.000Z","updated":"2022-02-12T12:18:15.683Z","comments":true,"path":"2021/08/14/其他/test/","link":"","permalink":"https://zhouyi.me/2021/08/14/%E5%85%B6%E4%BB%96/test/","excerpt":"this is a test page.","text":"this is a test page. $ hexo server","categories":[{"name":"test","slug":"test","permalink":"https://zhouyi.me/categories/test/"}],"tags":[]}],"categories":[{"name":"日记","slug":"日记","permalink":"https://zhouyi.me/categories/%E6%97%A5%E8%AE%B0/"},{"name":"test","slug":"test","permalink":"https://zhouyi.me/categories/test/"},{"name":"Java","slug":"Java","permalink":"https://zhouyi.me/categories/Java/"},{"name":"tools","slug":"tools","permalink":"https://zhouyi.me/categories/tools/"},{"name":"算法","slug":"算法","permalink":"https://zhouyi.me/categories/%E7%AE%97%E6%B3%95/"},{"name":"博客","slug":"博客","permalink":"https://zhouyi.me/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"数据结构","slug":"数据结构","permalink":"https://zhouyi.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://zhouyi.me/tags/%E6%97%A5%E8%AE%B0/"},{"name":"总结","slug":"总结","permalink":"https://zhouyi.me/tags/%E6%80%BB%E7%BB%93/"},{"name":"Java","slug":"Java","permalink":"https://zhouyi.me/tags/Java/"},{"name":"git","slug":"git","permalink":"https://zhouyi.me/tags/git/"},{"name":"github","slug":"github","permalink":"https://zhouyi.me/tags/github/"},{"name":"二叉树","slug":"二叉树","permalink":"https://zhouyi.me/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"算法","slug":"算法","permalink":"https://zhouyi.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"https://zhouyi.me/tags/%E9%9D%A2%E8%AF%95/"},{"name":"博客","slug":"博客","permalink":"https://zhouyi.me/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"数据结构","slug":"数据结构","permalink":"https://zhouyi.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序","slug":"排序","permalink":"https://zhouyi.me/tags/%E6%8E%92%E5%BA%8F/"},{"name":"编程","slug":"编程","permalink":"https://zhouyi.me/tags/%E7%BC%96%E7%A8%8B/"}]}