<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blue Cat</title>
  
  
  <link href="https://zhouyi.me/atom.xml" rel="self"/>
  
  <link href="https://zhouyi.me/"/>
  <updated>2022-08-17T18:53:54.551Z</updated>
  <id>https://zhouyi.me/</id>
  
  <author>
    <name>zy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java集合以及字符串常用方法</title>
    <link href="https://zhouyi.me/2021/11/03/Java/Java%E9%9B%86%E5%90%88%E4%BB%A5%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://zhouyi.me/2021/11/03/Java/Java%E9%9B%86%E5%90%88%E4%BB%A5%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2021-11-03T03:19:00.000Z</published>
    <updated>2022-08-17T18:53:54.551Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h4><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3">字符串相关</a></li><li><a href="#%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3">集合相关</a></li></ul><h4 id="字符串相关"><a class="markdownIt-Anchor" href="#字符串相关"></a> 字符串相关</h4><ul><li><p>String</p><ul><li><code>substring(int start);</code>或者 <code>substring(int index1, int index2);</code> 左闭右开</li><li><code>equals(); equalsIgnoreCase();</code> 后者不区分大小写</li><li><code>charAt(int index);</code> 获取字符，返回char</li><li><code>getChars(int index, int index2, char[] dst, int dstStart);</code> 左闭右开获取多个字符到dst数组，dst从dstStart开始存储。</li><li><code>compareTo();</code> 比较字符串</li><li><code>trim();</code> 去头部尾部的空格</li><li><code>split(String regex);</code> 返回字符串数组，按照regex进行分隔，一般是<code>&quot;&quot;</code>或者<code>&quot; &quot;</code></li><li><code>toCharArray();</code> 返回字符数组char[]</li><li><code>String.copyValueOf(char[] value, int offset, int count)</code> 返回一个字符串，在value里从offset开始拷贝count个字符</li><li><code>indexOf(String str);</code> 获取子串第一次出现的index，没有则返回-1</li><li><code>lastIndexOf(String str);</code> 获取子串最后一次出现的index，没有则返回-1</li><li><code>replaceAll(String regex, String replacement);</code> 用replacement替换所有regex字符串。</li><li><code>replace(char char1, char char2);</code> 用char2替换所有char1。</li><li><code>toLowerCase();</code></li><li><code>toUpperCase();</code></li><li><code>String.valueOf();</code>取字符串值，可传入基本类型</li></ul></li><li><p>StringBuilder</p><ul><li><code>append(String str);</code></li><li><code>toString();</code></li><li><code>setCharAt(int index, char c);</code> 将index位置替换成c</li><li><code>insert(int offset, String str);</code>或者<code>insert(int offset, char c);</code> 从offset开始插入字符串或者字符</li><li><code>delete(int start, int end);</code> 左闭右开区间 删除</li></ul></li></ul><h4 id="集合相关"><a class="markdownIt-Anchor" href="#集合相关"></a> 集合相关</h4><ul><li><p>Collection</p><ul><li><code>add(Object obj);</code></li><li><code>clear();</code></li><li><code>contains(Object o);</code></li><li><code>isEmpty();</code></li><li><code>iterator();</code> 返回迭代器 Iterator类型</li><li><code>size();</code></li></ul></li><li><p>List</p><ul><li><code>add(Object obj)</code>或者<code>add(int index, Object obj);</code> 在index位置上添加元素</li><li><code>addAll(int index, Collection e);</code></li><li><code>indexOf(Object o);</code></li><li><code>lastIndexOf();</code></li><li><code>get(index);</code></li><li><code>remove(index);</code> 返回被删除的元素。</li><li><code>set(int index, Object obj);</code> 修改index位置的元素，返回被修改的元素。</li></ul></li><li><p>LinkedList特有</p><ul><li><code>addFirst(Object obj);</code></li><li><code>addLast(Object obj;</code> 和<code>add()</code>一样，所以不常用</li><li><code>getFirst();</code></li><li><code>getLast();</code></li><li><code>removeFirst();</code></li><li><code>removeLast();</code></li></ul></li><li><p>Stack 继承于Vector，由于Vector也是通过数组实现的，说明stack也是通过数组实现的</p><ul><li><code>peek();</code></li><li><code>pop();</code></li><li><code>push(Object o);</code></li></ul></li><li><p>Queue接口 子接口有Deque双端队列 一般常见LinkedList实现</p><ul><li><code>add(Object o);</code></li><li><code>element();</code></li><li><code>offer(Object o);</code></li><li><code>peek();</code></li><li><code>poll();</code></li><li><code>remove();</code></li></ul></li><li><p>Set</p><ul><li><code>add(Object o);</code> 不存在则插入，存在则返回false</li><li><code>addAll(Collection c);</code></li><li><code>clear();</code></li><li><code>contains(Object o);</code></li><li><code>containsAll(Collection c);</code></li><li><code>remove(Object o);</code></li><li><code>removeAll(Collection c);</code></li></ul></li><li><p>Map</p><ul><li><code>containsKey(Object key);</code></li><li><code>containsValue(Object value);</code></li><li><code>entrySet();</code> 返回key-value的Set集合，返回值类型为Set</li><li>Entry<ul><li><code>getKey();</code></li><li><code>getValue();</code></li><li><code>setValue(Object obj);</code></li></ul></li><li><code>keySet();</code> 返回key的Set集合</li><li><code>values();</code> 返回values的集合 Collection类型</li><li><code>put(key, value);</code></li><li><code>get(key);</code></li><li><code>remove(key);</code></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h4 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%9B%AE%E5%BD%95&quot;&gt;目录&lt;/a&gt;&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Java" scheme="https://zhouyi.me/categories/Java/"/>
    
    
    <category term="Java" scheme="https://zhouyi.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Github项目目录中白色箭头怎么解决</title>
    <link href="https://zhouyi.me/2021/10/27/%E5%85%B6%E4%BB%96/Github%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%99%BD%E8%89%B2%E7%AE%AD%E5%A4%B4%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/"/>
    <id>https://zhouyi.me/2021/10/27/%E5%85%B6%E4%BB%96/Github%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%99%BD%E8%89%B2%E7%AE%AD%E5%A4%B4%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/</id>
    <published>2021-10-26T16:05:13.000Z</published>
    <updated>2022-02-12T12:18:15.682Z</updated>
    
    <content type="html"><![CDATA[<p>如何解决github中文件夹出现白色箭头且无法打开。</p><span id="more"></span><p>最近在弄博客的时候发现由于clone了pure的主题的仓库，个人做了些修改之后无法上传到github保存的问题。并且github目录中该目录图标会出现一个白色箭头，也无法打开。</p><!-- ![avatar](../pic/20211027/github_whitarrow.jpg) --><p><img src="https://zhouyi.me/pic/20211027/github_whitarrow.jpg" alt="avatar"></p><p>箭头的意味是表示该模块是个嵌套的子模块。<br>解决方法如下：</p><ol><li>删除该目录下的.git文件夹。</li><li>清除缓存<code>git rm -r --cached [dir]</code>，其中dir为文件夹名。</li><li>重新提交即可。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何解决github中文件夹出现白色箭头且无法打开。&lt;/p&gt;</summary>
    
    
    
    <category term="tools" scheme="https://zhouyi.me/categories/tools/"/>
    
    
    <category term="git" scheme="https://zhouyi.me/tags/git/"/>
    
    <category term="github" scheme="https://zhouyi.me/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历</title>
    <link href="https://zhouyi.me/2021/10/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <id>https://zhouyi.me/2021/10/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</id>
    <published>2021-10-25T04:12:22.000Z</published>
    <updated>2022-02-12T12:18:15.684Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的前序遍历，中序遍历，后序遍历与层序遍历。</p><span id="more"></span><h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li><li><a href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">前序遍历</a></li><li><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</a></li><li><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">后序遍历</a></li><li><a href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">层序遍历</a></li></ul><h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/1024px-Binary_tree.svg.png?80" alt="avatar"></p><ul><li>前（根）序遍历<br>按照 <strong>根-&gt;左-&gt;右</strong> 的顺序进行遍历。<br>上图前序遍历结果：2 - 7 - 2 - 6 - 5 - 11 - 5 - 9 - 4</li><li>中（根）序遍历<br>按照 <strong>左-&gt;根-&gt;右</strong> 的顺序进行遍历。<br>上图中序遍历结果：2 - 7 - 5 - 6 - 11 - 2 - 5 - 4 - 9</li><li>后（根）序遍历<br>按照 <strong>左-&gt;右-&gt;根</strong> 的顺序进行遍历。<br>上图后序遍历结果：2 - 5 - 11 - 6 - 7 - 4 - 9 - 5 -2</li><li>层序遍历<br>按照层级进行遍历，类似于图的广度优先搜索<br>上图层序遍历结果：2 - 7 - 5 - 2 - 6 - 9 - 5 - 11 - 4</li></ul><h3 id="前序遍历"><a class="markdownIt-Anchor" href="#前序遍历"></a> 前序遍历</h3><pre class="highlight"><code class="java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;            <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;                System.out.print(node.getVal()+<span class="hljs-string">" "</span>);                stack.push(node);                node = node.getLeft();            &#125;            <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;                TreeNode pop = stack.pop();                node = pop.getRight();            &#125;        &#125;    &#125;</code></pre><h3 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h3><pre class="highlight"><code class="java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MidOrder</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;            <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;                stack.push(node);                node = node.getLeft();            &#125;            <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;                TreeNode pop = stack.pop();                System.out.print(pop.getVal()+<span class="hljs-string">" "</span>);                node = pop.getRight();            &#125;        &#125;    &#125;</code></pre><h3 id="后序遍历"><a class="markdownIt-Anchor" href="#后序遍历"></a> 后序遍历</h3><pre class="highlight"><code class="java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PosOrder</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 保存最后一个被访问的节点，用来判断节点的右子树是否被访问过</span>        TreeNode lastVisitedNode = <span class="hljs-keyword">null</span>;        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;            <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;                stack.push(node);                node = node.getLeft();            &#125;            <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;                <span class="hljs-comment">// 一个节点可以访问的前提是自己没有右子树或者右子树被访问过</span>                TreeNode pop = stack.pop();                <span class="hljs-keyword">if</span> (pop.getRight() == <span class="hljs-keyword">null</span> || pop.getRight() == lastVisitedNode) &#123;                    lastVisitedNode = pop;                    System.out.print(pop.getVal() + <span class="hljs-string">" "</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    node = pop.getRight();                    stack.push(pop);                &#125;            &#125;        &#125;    &#125;</code></pre><h3 id="层序遍历"><a class="markdownIt-Anchor" href="#层序遍历"></a> 层序遍历</h3><pre class="highlight"><code class="java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LevOrder</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.offer(node);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            TreeNode poll = queue.poll();            System.out.print(poll.getVal()+<span class="hljs-string">" "</span>);            <span class="hljs-keyword">if</span> (poll.getLeft() != <span class="hljs-keyword">null</span>) &#123;                queue.offer(poll.getLeft());            &#125;            <span class="hljs-keyword">if</span> (poll.getRight() != <span class="hljs-keyword">null</span>) &#123;                queue.offer(poll.getRight());            &#125;        &#125;    &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;二叉树的前序遍历，中序遍历，后序遍历与层序遍历。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://zhouyi.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="https://zhouyi.me/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="算法" scheme="https://zhouyi.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面试准备</title>
    <link href="https://zhouyi.me/2021/10/25/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <id>https://zhouyi.me/2021/10/25/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</id>
    <published>2021-10-25T04:01:06.000Z</published>
    <updated>2022-08-17T17:55:53.631Z</updated>
    
    <content type="html"><![CDATA[<p>个人面试准备的复习资料。</p><span id="more"></span><h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#java%E5%9F%BA%E7%A1%80">Java基础</a></li><li><a href="#mysql">Mysql</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">计算机网络和操作系统</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95">数据结构与算法</a></li><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></li><li><a href="#redis">Redis</a></li><li><a href="#spring%E7%9B%B8%E5%85%B3">Spring相关</a></li><li><a href="#%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0">个人项目笔记</a></li></ul><h3 id="java基础"><a class="markdownIt-Anchor" href="#java基础"></a> Java基础</h3><ul><li><a href="">Java基础</a></li><li><a href="">JVM</a></li><li><a href="">多线程</a></li><li><a href="">Java集合容器</a></li><li><a href="">Java反射注解泛型</a></li></ul><h3 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> Mysql</h3><ul><li><a href="">mysql应用篇</a></li><li><a href="">mysql原理篇</a></li></ul><h3 id="计算机网络和操作系统"><a class="markdownIt-Anchor" href="#计算机网络和操作系统"></a> 计算机网络和操作系统</h3><ul><li><a href="">计算机网络</a></li><li><a href="">操作系统</a></li></ul><h3 id="数据结构与算法"><a class="markdownIt-Anchor" href="#数据结构与算法"></a> 数据结构与算法</h3><ul><li><a href="https://zhouyi.me/2021/10/25/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li><a href="https://zhouyi.me/2021/10/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></li><li><a href="">二叉树遍历</a></li></ul><h3 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h3><ul><li><a href="">单例模式</a></li><li><a href="">工厂模式</a></li><li><a href="">代理模式</a></li></ul><h3 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h3><ul><li><a href="">Redis知识复习</a></li></ul><h3 id="spring相关"><a class="markdownIt-Anchor" href="#spring相关"></a> Spring相关</h3><ul><li><a href="">Spring</a></li><li><a href="">SpringBoot</a></li><li><a href="">Mybatis</a></li></ul><h3 id="个人项目笔记"><a class="markdownIt-Anchor" href="#个人项目笔记"></a> 个人项目笔记</h3><ul><li><a href="">论坛管理项目</a></li><li><a href="">Spring容器项目</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;个人面试准备的复习资料。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://zhouyi.me/categories/Java/"/>
    
    
    <category term="Java" scheme="https://zhouyi.me/tags/Java/"/>
    
    <category term="面试" scheme="https://zhouyi.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>关于个人博客评论系统gitalk的一些错误</title>
    <link href="https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%85%B3%E4%BA%8E%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9Fgitalk%E7%9A%84%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF/"/>
    <id>https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%85%B3%E4%BA%8E%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9Fgitalk%E7%9A%84%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF/</id>
    <published>2021-10-24T18:24:16.000Z</published>
    <updated>2022-02-12T12:18:15.683Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;</summary>
      
    
    
    
    <category term="博客" scheme="https://zhouyi.me/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://zhouyi.me/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>将github.io个人博客网址收录到搜索引擎</title>
    <link href="https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%B0%86github-io%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E5%9D%80%E6%94%B6%E5%BD%95%E5%88%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    <id>https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%B0%86github-io%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E5%9D%80%E6%94%B6%E5%BD%95%E5%88%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</id>
    <published>2021-10-24T18:22:33.000Z</published>
    <updated>2022-02-12T12:18:15.683Z</updated>
    
    <content type="html"><![CDATA[<p>此博客记录如何将github.io的博客提交到搜索引擎中收录。</p><span id="more"></span><h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%AB%99%E6%98%AF%E5%90%A6%E8%A2%AB%E6%94%B6%E5%BD%95">查看网站是否被收录</a></li><li><a href="#%E7%94%9F%E6%88%90%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE">生成站点地图</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E5%88%B0google">添加到Google</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E5%88%B0bing">添加到Bing</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E5%88%B0baidu">添加到Baidu</a><ul><li><a href="#baidu%E4%B8%BB%E5%8A%A8%E6%8F%90%E4%BA%A4">Baidu主动提交</a></li></ul></li></ul><h3 id="查看网站是否被收录"><a class="markdownIt-Anchor" href="#查看网站是否被收录"></a> 查看网站是否被收录</h3><p>在搜索引擎输入以下命令进行搜索。</p><pre class="highlight"><code class="">site:zhouyi.me</code></pre><p>出现如下回应则表示被收录的，否则就是没有</p><!-- ![avatar](../pic/20211025/google_search.png) --><p><img src="https://zhouyi.me/pic/20211025/google_search.png" alt="avatar"></p><h3 id="生成站点地图"><a class="markdownIt-Anchor" href="#生成站点地图"></a> 生成站点地图</h3><p>hexo是有生成站点地图的插件的，输入以下命令进行安装。</p><pre class="highlight"><code class="">npm install hexo-generator-sitemap</code></pre><p>之后每次生成静态文件的时候目录下就会有站点地图文件<code>sitemap.xml</code>。</p><h3 id="添加到google"><a class="markdownIt-Anchor" href="#添加到google"></a> 添加到Google</h3><p>登录<a href="https://search.google.com/search-console">google search console</a>。</p><p>添加站点资源，在网址前缀类型中输入网址。</p><!-- ![avatar](../pic/20211025/google_add_url.png) --><p><img src="https://zhouyi.me/pic/20211025/google_add_url.png" alt="avatar"></p><p>之后需要进行验证，验证方法有以下几种。</p><!-- ![avatar](../pic/20211025/google_verify_methods.png) --><p><img src="https://zhouyi.me/pic/20211025/google_verify_methods.png" alt="avatar"></p><p>如果采用html文件验证的话，如果采用hexo则需要设置不针对此文件进行生成静态文件，这里可以自行查看<a href="https://hexo.io/zh-cn/docs/configuration">官方网站</a>配置说明。<br>不设置好的话，html文件会套用主题模板变成一个博客主题页面。</p><p>个人没有详细去看，觉得比较麻烦，就直接采用了第二种HTML标记验证法，即在模板文件的<code>&lt;head&gt;</code>标签加入指定<code>&lt;meta&gt;</code>元素即可，这个可能根据主题不同而不同，pure主题则是更改<code>pure/layout/_common/head.ejs</code>模板文件，其他主题原理应该差不多。</p><p>之后提交站点地图即可。根据hexo插件自动生成，文件名为<code>sitemap.xml</code>。</p><!-- ![avatar](../pic/20211025/google_add_sitemap.png) --><p><img src="https://zhouyi.me/pic/20211025/google_add_sitemap.png" alt="avatar"></p><h3 id="添加到bing"><a class="markdownIt-Anchor" href="#添加到bing"></a> 添加到Bing</h3><p>登录Bing的<a href="https://www.bing.com/webmasters/home">webmaster控制台</a>。</p><p>添加站点资源。</p><!-- ![avatar](../pic/20211025/bing_add_url.png) --><p><img src="https://zhouyi.me/pic/20211025/bing_add_url.png" alt="avatar"></p><p>之后进行验证。</p><!-- ![avatar](../pic/20211025/bing_verify_methods.png) --><p><img src="https://zhouyi.me/pic/20211025/bing_verify_methods.png" alt="avatar"></p><p>第一种方法，将给出的xml文件放入项目目录中，和CNAME文件一样，由于每次都会生成静态文件，直接添加到源文件CNAME同级目录下即可，即<code>source</code>目录下。</p><p>第二种方法，和添加到Google的方法一样，添加<code>&lt;meta&gt;</code>元素。</p><p>之后添加站点地图。根据hexo插件自动生成，文件名为<code>sitemap.xml</code>。</p><!-- ![avatar](../pic/20211025/bing_add_sitemap.png) --><p><img src="https://zhouyi.me/pic/20211025/bing_add_sitemap.png" alt="avatar"></p><h3 id="添加到baidu"><a class="markdownIt-Anchor" href="#添加到baidu"></a> 添加到Baidu</h3><p>百度则相对比较麻烦一点。<br>首先登陆到<a href="https://ziyuan.baidu.com/linksubmit/">站点管理控制台</a><br><img src="https://zhouyi.me/pic/20211025/baidu_add_url.png" alt="avatar"></p><p>添加站点资源。</p><!-- ![avatar](../pic/20211025/baidu_add_url.png) --><p><img src="https://zhouyi.me/pic/20211025/baidu_add_url.png" alt="avatar"></p><p>之后进行验证。</p><!-- ![avatar](../pic/20211025/baidu_verify_methods.png) --><p><img src="https://zhouyi.me/pic/20211025/baidu_verify_methods.png" alt="avatar"><br>如果采用第二种方法，和添加到Google的方法一样，添加<code>&lt;meta&gt;</code>元素。</p><p>之后进行提交站点地图。<br>百度有专门的站点地图，我也不知道为啥，看了一眼生成的文件其实差不多。输入以下命令安装插件，之后生成静态文件的时候会在<code>sitemap.xml</code>同级目录下生成<code>baidusitemap.xml</code>。我们直接两个都提交。</p><pre class="highlight"><code class="">npm install hexo-generator-baidu-sitemap</code></pre><!-- ![avatar](../pic/20211025/baidu_add_sitemap.png) --><p><img src="https://zhouyi.me/pic/20211025/baidu_add_sitemap.png" alt="avatar"></p><p>由于Baidu爬虫有无法爬取Github pages的错误，需要各种手段解决，最近看到这一篇文章算是比较好的解决方案，下面是大佬的博客链接：</p><ul><li><a href="https://zpjiang.me/2020/01/15/let-baidu-index-github-page/">解决百度爬虫无法爬取 Github Pages 个人博客的问题</a></li></ul><h4 id="baidu主动提交"><a class="markdownIt-Anchor" href="#baidu主动提交"></a> Baidu主动提交</h4><p>除了提交sitemap，我们也可以主动提交。</p><!-- ![avatar](../pic/20211025/baidu_add_api.png) --><p><img src="https://zhouyi.me/pic/20211025/baidu_add_api.png" alt="avatar"><br>首先，输入以下命令安装插件</p><pre class="highlight"><code class="">npm install hexo-baidu-url-submit</code></pre><p>之后在<code>_config.yml</code>文件添加如下配置，如下：</p><pre class="highlight"><code class="">baidu_url_submit:  count: 30  // 提交最新的多少链接  host: https://zhouyi.me // 添加的域名  token: xxxxxx // 上图中的token  path: baidu_urls.txt// 另外添加一行 type: baidu_url_submitter 注意在两个type前加上 -deploy:- type: git  repo: https://github.com/blue-zy/blue-zy.github.io.git- type: baidu_url_submitter</code></pre><p>之后进行部署</p><pre class="highlight"><code class="">hexo cleanhexo ghexo d</code></pre><p>根据api提交反馈信息</p><!-- ![avatar](../pic/20211025/baidu_add_api_success.png) --><p><img src="https://zhouyi.me/pic/20211025/baidu_add_api_success.png" alt="avatar"></p><p>若输出如下形式，则表示推送成功</p><pre class="highlight"><code class="">&#123;&quot;remain&quot;:2988,&quot;success&quot;:12&#125;INFO  Deploy done: baidu_url_submitter</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;此博客记录如何将github.io的博客提交到搜索引擎中收录。&lt;/p&gt;</summary>
    
    
    
    <category term="博客" scheme="https://zhouyi.me/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://zhouyi.me/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://zhouyi.me/2021/10/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://zhouyi.me/2021/10/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-10-24T18:00:53.000Z</published>
    <updated>2022-02-12T12:18:15.684Z</updated>
    
    <content type="html"><![CDATA[<p>此文介绍常见的数据结构</p><span id="more"></span><h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">什么是数据结构</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">常见的数据结构</a></li><li><a href="#%E7%BA%BF%E6%80%A7%E8%A1%A8">线性表</a></li><li><a href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97">栈和队列</a><ul><li><a href="#%E6%A0%88">栈</a></li><li><a href="#%E9%98%9F%E5%88%97">队列</a></li></ul></li><li><a href="#%E4%B8%B2">串</a></li><li><a href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8">数组和广义表</a><ul><li><a href="#%E6%95%B0%E7%BB%84">数组</a></li><li><a href="#%E5%B9%BF%E4%B9%89%E8%A1%A8">广义表</a></li></ul></li><li><a href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91">树和二叉树</a><ul><li><a href="#%E6%A0%91">树</a></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a></li></ul></li><li><a href="#%E5%9B%BE">图</a></li><li><a href="#%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a></li></ul><h3 id="什么是数据结构"><a class="markdownIt-Anchor" href="#什么是数据结构"></a> 什么是数据结构</h3><p>基本概念和术语</p><ul><li>数据<br>是对客观事物的符号表示，在计算机科学中，含义非常广泛，如图像，声音等都可以通过编码归类于数据的范畴。</li><li>数据元素<br>是数据的基本单位，在程序中通常作为一个整体，而一个数据元素又有可能含有多个<strong>数据项</strong>，数据项是不可分割的最小单位。</li><li>数据对象<br>性质相同的数据元素的集合，数据的子集，比如整数数据对象（集），字符数据对象（集）。</li><li>数据结构<br>是相互之间存在一种或者多种特定关系的数据元素的集合。<br>数据元素相互之间的关系称为结构，常见的关系有：<ul><li>集合：除了同属于一个集合外别无其他关系。如公司的员工名单表，无其他信息。</li><li>线性结构：数据元素存在一个对一个的关系。如公司的员工名单带有工号按一定顺序排序。</li><li>树形结构：数据元素存在一个对多个的关系。如公司的员工之间存在上下级关系，一个上级有多个下级。</li><li>图状结构/网状结构：数据元素存在多个对多个的关系。如公司之间各个部门的协作关系。</li></ul></li></ul><p>上述所说的数据结构实则是数据元素之间的逻辑关系，即<strong>逻辑结构</strong>。<br>数据结构在计算机中的表示（映像）称为数据的<strong>物理结构</strong>，也称为<strong>存储结构</strong>。</p><ul><li>顺序映像对应顺序存储结构，根据相对位置。</li><li>非顺序映像对应链式存储结构，根据指针。</li></ul><h3 id="常见的数据结构"><a class="markdownIt-Anchor" href="#常见的数据结构"></a> 常见的数据结构</h3><ul><li>线性表</li><li>栈和队列</li><li>串</li><li>数组和广义表</li><li>树和二叉树</li><li>图</li><li>哈希表</li></ul><h3 id="线性表"><a class="markdownIt-Anchor" href="#线性表"></a> 线性表</h3><p>线性表是一种线性结构，线性结构的特点是：</p><ul><li>存在唯一一个被称为“第一个”的数据元素</li><li>存在唯一一个被称为“最后一个”的数据元素</li><li>除了第一个之外，每个数据元素均只有一个前驱</li><li>除了最后一个之外，每个数据元素均只有一个后继</li></ul><p>线性表中存储的数据类型必须一致。</p><p>两种存储结构：</p><ul><li><p>顺序存储结构<br>顺序表，用一组地址连续的存储单元一次存储线性表的数据元素。</p></li><li><p>链式存储结构<br>链表，用一组任意的存储单元存储线性表的数据元素。除了存储本身的信息之外，还需要存储一个指示其直接后继的信息。</p><ul><li>指针域</li><li>数据域</li></ul><p>另外两种形式的链式存储结构：</p><ul><li>循环链表</li><li>双向链表</li></ul></li></ul><h3 id="栈和队列"><a class="markdownIt-Anchor" href="#栈和队列"></a> 栈和队列</h3><h4 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h4><p>定义：栈是限定仅在表尾进行插入或者删除操作的线性表，即FILO。</p><ul><li>栈顶：表尾</li><li>栈底：表头</li></ul><p>两种存储表示方法：</p><ul><li>顺序栈：利用一组地址连续的存储单元一次存放自栈底到栈顶元素。</li><li>链栈：利用链表实现栈的存储结构。</li></ul><h4 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h4><p>定义：队列是一种符合FIFO原则的线性表。</p><ul><li>队头：只允许删除元素。</li><li>队尾：只允许插入元素。</li></ul><p>两种存储表示方法：</p><ul><li>顺序队列：地址连续的存储单元。</li><li>链队列：利用链表实现。</li></ul><p>另两种数据结构：</p><ul><li>双端队列</li><li>循环队列</li></ul><h3 id="串"><a class="markdownIt-Anchor" href="#串"></a> 串</h3><p>定义：串（或字符串）是有零个或者多个字符组成的有限序列。<br>串的逻辑结构和线性表极为相似，区别仅在于传中的数据对象约束为字符集。</p><p>三种存储表示方法：</p><ul><li><p>定长顺序存储<br>类似线性表的顺序存储结构，地址连续的存储单元。分配定长，超长部分会被截断。</p></li><li><p>堆分配存储表示<br>地址连续，但存储空间是程序执行中动态分配的。如C语言中，存在一个自由存储去称为“堆”，可以由<code>malloc()</code>和<code>free()</code>管理。</p></li><li><p>块链存储表示<br>和链表类似，但每个节点可以存储一个字符，也可以存储多个字符，因此最后一个结点不一定全被串值占满，通常会补上其他非串值字符如<code>#</code>。</p><ul><li>存储密度 = 串值所占存储位/实际分配存储位</li></ul></li><li><p>串的模式匹配算法和KMP算法<br>参考<a href="">字符串相关算法</a></p></li></ul><h3 id="数组和广义表"><a class="markdownIt-Anchor" href="#数组和广义表"></a> 数组和广义表</h3><h4 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h4><p>线性表讨论的都是数据元素不可再分的情况，而数组可以存储本身也是一种数据结构的数据元素。<br>如二维数组，可以看成一个线性表中存储的元素是数组。<br>但是数据类型必须一致。</p><p>数组结构通常使用<strong>顺序存储结构</strong>，通常只做查找和修改操作，而插入和删除操作效率是很差的。</p><h4 id="广义表"><a class="markdownIt-Anchor" href="#广义表"></a> 广义表</h4><p>数组可以存储不可再分的数据元素，也可以存储数组，但是数据类型必须一致，而广义表去掉了这种限制。<br>广义表又称列表，也是一种线性存储结构，广义表中既可以存储不可再分元素，也可以存储广义表。</p><p>广义表通常使用<strong>链表</strong>实现，因为里面存储的元素种类不一，顺序表比较难以处理。</p><h3 id="树和二叉树"><a class="markdownIt-Anchor" href="#树和二叉树"></a> 树和二叉树</h3><h4 id="树"><a class="markdownIt-Anchor" href="#树"></a> 树</h4><p>定义：树是n个结点的有限集，任意一棵非空树中：</p><ul><li>有且仅有一个根节点</li><li>当n&gt;1时，其余结点又可分为m(m&gt;0)个互不相交的有限集，而它们也是树，称为根节点的子树</li></ul><p>术语：</p><ul><li>结点的度：结点拥有的子树数量</li><li>叶子结点/终端结点</li><li>分支结点/非终端结点</li><li>双亲</li><li>孩子</li><li>兄弟：同一个双亲结点的孩子们</li><li>祖先：从根结点到该结点的所有结点</li><li>子孙：以该结点为根的子树的任一结点</li><li>层次：根为第一层，根的孩子为第二层，以此类推</li><li>堂兄弟：双亲结点在同一层的结点</li><li>深度：最大层次称为树的深度</li><li>森林：不相交的树</li></ul><h4 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h4><p>定义：每个结点至多只有两个子树的树，且子树有左右之分。</p><p>性质：</p><ol><li>第i层上至多有2^(i-1)个结点。</li><li>深度为k的二叉树至多有2^k - 1个结点。</li><li>若终端结点数为n0，度为2的结点数为n2，则n0=n2+1。</li><li>具有n个结点的完全二叉树深度为log2(n)+1。</li><li>略。</li></ol><p>二叉树的存储结构</p><ul><li>顺序存储结构<br>通过添加一些额外结点，将树构建成一棵完全二叉树，按照层次（从上往下，从左往右）顺序存储。</li><li>链式存储结构<br>包含三个域，有时还多出一个指向双亲结点的指针域<ul><li>数据域</li><li>左子树，指针</li><li>右子树，指针</li></ul></li></ul><p>二叉树的遍历</p><ul><li>先序遍历：根 – 左 – 右</li><li>中序遍历：左 – 根 – 右</li><li>后序遍历：左 – 右 – 根</li><li>层次遍历：从上往下，从左往右。<br>详情参考<a href="https://zhouyi.me/2021/10/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/">此篇文章</a>。</li></ul><p>线索二叉树（对于链式存储）</p><ul><li>概念：若结点有左子树，lchild指向左子树，否则指向前驱，若结点有右子树，rchild指向右子树，否则指向后继。</li><li>新增两个标志位LTag和RTag，分别代表有无左右子树。</li><li>以上述结点结构构成的二叉树的存储结构，称为线索链表，指向前驱和后继的指针称为线索，加上线索的二叉树称为线索二叉树。</li></ul><p>另外，</p><ul><li>给出<strong>先序</strong>遍历和<strong>后序</strong>遍历，不能唯一确定一棵二叉树。因为先序和后序只是反映了结点间的父子关系，没有反映出左右关系。</li><li>给出<strong>先序</strong>遍历或者<strong>后序</strong>遍历，再给出<strong>中序</strong>遍历，能够唯一确定一棵二叉树。</li></ul><p>特殊的二叉树</p><ul><li><p>满二叉树：深度为k时，结点数量为2^k - 1。</p></li><li><p>完全二叉树：深度为k时，所有结点的编号与深度为k的满二叉树一一对应。</p><ul><li>路径：一个结点到另一个结点的途径。</li><li>路径长度：路径上的分支数目，即每经过一个结点长度加1。</li><li>树的路径长度：树根到每一个结点的路径长度之和。</li><li>完全二叉树就是路径长度最短的二叉树。</li></ul></li><li><p>最优二叉树</p><ul><li><p>结点带权路径：该结点到树根之间的路径长度与结点的权值乘积。</p></li><li><p>树的带权路径长度：树中所有<strong>叶子结点</strong>的带权路径长度之和。</p></li><li><p>带权路径长度WPL最小的二叉树即为最优二叉树/赫夫曼树。</p></li><li><p>赫夫曼算法：用来构建赫夫曼树</p><ul><li>根据给定的n个权值构成n棵二叉树集合F，其中每棵二叉树中只有一个带权的根结点，无子树。</li><li>从F中选出两棵根结点权值最小的树，作为左右子树构建一棵新二叉树，新二叉树的根权值为这俩之和。</li><li>将新二叉树加入到F中，移除第二步的两个二叉树。</li><li>重复2和3。<br><img src="https://upload.wikimedia.org/wikipedia/commons/d/d8/HuffmanCodeAlg.png" alt="avatar"></li></ul></li><li><p>赫夫曼编码：<br>对于设计长度不等的编码的情况，必须要任一个字符的编码都不是另一个字符的编码的前缀，这种编码称为前缀编码。<br>利用赫夫曼树进行编码如下图所示。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/74/Huffman_coding_example.svg/640px-Huffman_coding_example.svg.png" alt="avatar"><br>编码结果：</p><table><thead><tr><th>字符</th><th>编码</th></tr></thead><tbody><tr><td>a1</td><td>0</td></tr><tr><td>a2</td><td>10</td></tr><tr><td>a3</td><td>110</td></tr><tr><td>a4</td><td>111</td></tr></tbody></table></li></ul></li></ul><p><a href="https://www.jianshu.com/p/ebbae6e80273%EF%BC%88%E5%90%84%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%A0%91%E6%80%BB%E7%BB%93%EF%BC%89">https://www.jianshu.com/p/ebbae6e80273（各种特殊树总结）</a></p><ul><li><p>二叉排序树</p></li><li><p>平衡二叉树，自平衡二叉树-AVL</p><ul><li><a href="https://zhuanlan.zhihu.com/p/56066942">https://zhuanlan.zhihu.com/p/56066942</a> （平衡二叉树及旋转之类的）</li></ul></li><li><p>红黑树</p></li><li><p>B树</p></li><li><p>B+树</p></li><li><p>B*树</p></li><li><p>回溯法</p><ul><li>互换</li><li>递归</li><li>换回来</li></ul></li></ul><h3 id="图"><a class="markdownIt-Anchor" href="#图"></a> 图</h3><p>定义：图形之中，结点之间的关系是任意的，任何两个结点都有可能相关。</p><p>术语：</p><ul><li>顶点V：数据元素</li><li>弧，弧头，弧尾：有向图中一个顶点到另一个顶点的表示</li><li>若弧是无序的，则为无向图，此时可称为边</li><li>完全图：不考虑顶点到自身的边的话，n个结点有n(n-1)/2条边</li><li>有向完全图：不考虑顶点到自身的弧的话，n个结点有n(n-1)条弧</li><li>稀疏图：边少的图，比如边&lt;nlogn</li><li>稠密图</li><li>子图</li><li>邻接点：无向图中有边连接的两个顶点，称这条边与这两个顶点相关联</li><li>顶点的度：和顶点相关联的边的数目</li><li>入度：以顶点为头的弧的数量</li><li>出度：以顶点为尾的弧的数量</li><li>路径：顶点序列</li><li>回路/环：第一个顶点和最后一个顶点相同的路径</li><li>简单路径：序列中顶点不重复的路径</li><li>简单回路/简单环：除了第一个顶点和最后一个顶点，序列中顶点不重复的回路</li><li>连通：顶点之间有路径</li><li>连通图：任意两个顶点都有路径</li><li>连通分量：无向图中的极大连通子图</li><li>强连通图：每一对结点都有两条路径，因为有向，所以这里的两条路径是反向的（但不一定要相同结点序列）</li><li>强连通分量：有向图中极大强连通分量</li><li>连通图的生成树：极小连通子图，含有图中全部结点，只有足以构成一棵树的n-1条边</li></ul><p>图的存储结构：</p><ul><li>无顺序映像存储结构，但是可以借助数组来表示元素之间的关系。</li><li>多重链表，邻接表，邻接多重表，十字链表。</li></ul><p>图的遍历：</p><ul><li>深度优先搜索：类似树的先序遍历</li><li>广度优先搜索：类似树的按层次遍历</li></ul><p>图的连通性问题：</p><h3 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h3><p>定义：</p><p><a href="https://blog.csdn.net/qq_29462849/article/details/88930870">https://blog.csdn.net/qq_29462849/article/details/88930870</a><br>哈希函数的构造方法：</p><ul><li>直接定址法</li><li>数字分析法</li><li>平方取中法</li><li>折叠法</li><li>除留余数法</li></ul><p>处理哈希冲突的方法：</p><ul><li>开放定址法 线性探测</li><li>再哈希法</li><li>链地址法</li><li>建立公共溢出区</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;此文介绍常见的数据结构&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://zhouyi.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zhouyi.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>将Github.io绑定到Godaddy域名</title>
    <link href="https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%B0%86Github-io%E7%BB%91%E5%AE%9A%E5%88%B0Godaddy%E5%9F%9F%E5%90%8D/"/>
    <id>https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%B0%86Github-io%E7%BB%91%E5%AE%9A%E5%88%B0Godaddy%E5%9F%9F%E5%90%8D/</id>
    <published>2021-10-24T16:55:38.000Z</published>
    <updated>2022-02-12T12:18:15.683Z</updated>
    
    <content type="html"><![CDATA[<p>此文章介绍如何绑定github pages到个性域名。</p><span id="more"></span><h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E5%9F%9F%E5%90%8D%E8%B4%AD%E4%B9%B0">域名购买</a></li><li><a href="#%E8%AE%BE%E7%BD%AEdns%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90">设置dns域名解析</a></li><li><a href="#github-pages%E8%AE%BE%E7%BD%AE%E5%92%8C%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE">github pages设置和项目设置</a></li></ul><h3 id="域名购买"><a class="markdownIt-Anchor" href="#域名购买"></a> 域名购买</h3><p>本文以<a href="https://sg.godaddy.com/">Godaddy</a>为例说明。<br>直接在输入框输入想要注册的域名。</p><!-- ![avatar](../pic/20211025/goddy_domain_search.png) --><p><img src="https://zhouyi.me/pic/20211025/goddy_domain_search.png" alt="avatar"></p><p>拿下，接着跳转到付款页面。</p><!-- ![avatar](../pic/20211025/goddy_cart.png) --><p><img src="https://zhouyi.me/pic/20211025/goddy_cart.png" alt="avatar"></p><p>全选No Thanks，继续。</p><!-- ![avatar](../pic/20211025/goddy_cart2.png) --><p><img src="https://zhouyi.me/pic/20211025/goddy_cart2.png" alt="avatar"></p><p>付款页面支持Alipay，这点还是挺方便的。</p><!-- ![avatar](../pic/20211025/goddy_alipay.png) --><p><img src="https://zhouyi.me/pic/20211025/goddy_alipay.png" alt="avatar"></p><h3 id="设置dns域名解析"><a class="markdownIt-Anchor" href="#设置dns域名解析"></a> 设置dns域名解析</h3><p>我们不用自带的域名解析，直接用<a href="https://www.dnspod.cn/">DNSPOD</a>解析。<br>首先我们先看看github.io的IP地址，直接ping或者nslookup也行。</p><pre class="highlight"><code class="">ping username.github.io // username为个人用户名nslookup username.github.io // username为个人用户名</code></pre><p>基本上是四个，而ping出来的就一个，那么我们待会就设置ping出来的这个就好了，假设为<code>185.199.111.153</code>。</p><ul><li><code>185.199.108.153</code></li><li><code>185.199.109.153</code></li><li><code>185.199.110.153</code></li><li><code>185.199.111.153</code></li></ul><p>登录DNSPOD之后，进入控制台的DNS解析，添加记录。</p><!-- ![avatar](../pic/20211025/dnspod.png) --><p><img src="https://zhouyi.me/pic/20211025/dnspod.png" alt="avatar"></p><p>其实就添加两条</p><ul><li>主机记录：@ 记录类型：A</li><li>主机记录：www 记录类型：CNAME</li></ul><p>另外，我们将默认的两个记录值记下，需要在Goddy中配置。注意不需要<code>.</code>。</p><ul><li><code>concrete.dnspod.net</code></li><li><code>poult.dnspod.net</code></li></ul><p>登录Goddy之后，右上角进入My Product选择域名的DNS settings，设置成以下的即可。</p><!-- ![avatar](../pic/20211025/goddy_dnspod.png) --><p><img src="https://zhouyi.me/pic/20211025/goddy_dnspod.png" alt="avatar"></p><h3 id="github-pages设置和项目设置"><a class="markdownIt-Anchor" href="#github-pages设置和项目设置"></a> github pages设置和项目设置</h3><p>之后我们向github.io项目中添加一个名为<code>CNAME</code>(大写) 的文件，里面只包含顶级域名，如下：</p><pre class="highlight"><code class="">zhouyi.me</code></pre><!-- ![avatar](../pic/20211025/github_CNAME.png) --><p><img src="https://zhouyi.me/pic/20211025/github_CNAME.png" alt="avatar"></p><p>之后，从项目的setting中进入github pages的设置页，如下设置即可。</p><!-- ![avatar](../pic/20211025/github_pages_domain.png) --><p><img src="https://zhouyi.me/pic/20211025/github_pages_domain.png" alt="avatar"></p><p>另外，如果我们用hexo部署的话，每次都会重新生成静态文件，因此我们需要直接将<code>CNAME</code>文件放入部署博客的源码中的<code>source</code>目录下，这样每次生成静态文件就会带上此目录的<code>CNAME</code>文件。</p><p>最后，记得更改项目中的<code>_config.yml</code>设置文件。</p><pre class="highlight"><code class="">url: https://zhouyi.me/</code></pre><p>有些插件如生成sitemap的插件是根据此来生成的，关于如何生成站点地图以及提交网址到搜索引擎请参考<a href="https://zhouyi.me/2021/09/24/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/#%E5%B0%86%E7%BD%91%E5%9D%80%E6%94%B6%E5%BD%95%E5%88%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">此链接</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;此文章介绍如何绑定github pages到个性域名。&lt;/p&gt;</summary>
    
    
    
    <category term="博客" scheme="https://zhouyi.me/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://zhouyi.me/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>利用Hexo和Github.io搭建静态博客</title>
    <link href="https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%88%A9%E7%94%A8Hexo%E5%92%8CGithub-io%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%88%A9%E7%94%A8Hexo%E5%92%8CGithub-io%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-10-24T16:45:38.000Z</published>
    <updated>2022-02-12T12:18:15.683Z</updated>
    
    <content type="html"><![CDATA[<p>此博客介绍如何将Hexo部署到Github pages上。</p><span id="more"></span><h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E5%AE%89%E8%A3%85nodejs">安装nodejs</a></li><li><a href="#%E5%AE%89%E8%A3%85hexo">安装hexo</a></li><li><a href="#%E8%AE%BE%E7%BD%AEgithub-pages">设置Github pages</a></li><li><a href="#%E9%83%A8%E7%BD%B2hexo">部署hexo</a></li><li><a href="#%E5%A4%87%E4%BB%BD%E5%8D%9A%E5%AE%A2">备份博客</a></li></ul><h3 id="安装nodejs"><a class="markdownIt-Anchor" href="#安装nodejs"></a> 安装nodejs</h3><p>首先下载Node.js<a href="https://nodejs.org/en/download/">安装程序</a>，Windows用户请确保勾选Add to PATH选项。<br>如果没有勾选此选项需要手动添加Node.js到环境变量。手动添加的步骤如下：</p><ul><li>右键点击此电脑，选择属性 -&gt; 高级系统设置 -&gt; 环境变量</li><li>双击<strong>系统变量</strong>中的的path点击新建</li><li>输入安装Node.js的路劲，即<code>npm.cmd</code>和<code>npx.cmd</code>所在文件夹</li></ul><!-- ![avatar](./../pic/20211025/path.png) --><p><img src="https://zhouyi.me/pic/20211025/path.png" alt="avatar"></p><h3 id="安装hexo"><a class="markdownIt-Anchor" href="#安装hexo"></a> 安装hexo</h3><p>输入<code>win+r</code>输入<code>cmd</code>，在命令提示符中输入<code>npm i -g hexo-cli</code>安装hexo。<br>输入<code>hexo -v</code>出现hexo版本信息表示安装成功。</p><h3 id="设置github-pages"><a class="markdownIt-Anchor" href="#设置github-pages"></a> 设置Github pages</h3><p>首先在github中新建一个项目，项目名为<code>username.github.io</code>，username为你的github账户名。</p><!-- ![avatar](../pic/20211025/github_new.png) --><p><img src="https://zhouyi.me/pic/20211025/github_new.png" alt="avatar"></p><p>接着点击setting，往下直到github pages部分，点进去。</p><pre class="highlight"><code class="">Pages settings now has its own dedicated tab! Check it out here!</code></pre><!-- ![avatar](../pic/20211025/github_pages_published.png) --><p><img src="https://zhouyi.me/pic/20211025/github_pages_published.png" alt="avatar"><br>浏览器输入 <a href="https://zhouzhou84751.github.io/">https://zhouzhou84751.github.io/</a> 即可以进入自己的github pages。</p><p>接着关联本地的git和github。<br>打开命令提示符输入以下命令。</p><pre class="highlight"><code class="">git config --global user.name &quot;username&quot; // username根据自己的github账号填入git config --global user.email &quot;xxx@xxx.com&quot; // email根据自己的github账号填入ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot; // email根据自己的github账号填入 一路回车即可// ssh密钥默认生成在~/.ssh/id_rsa.pubcat ~/.ssh/id_rsa.pub// windows目录下直接拷贝也行// 默认目录如下 C:\Users\你的用户名\.ssh\id_rsa.pub，直接用编辑器打开复制下来</code></pre><p>接着在github页面右上角的用户名中点击Settings，选择左侧SSH and GPG keys，New一个SSH key。<br>Title随便填，Key粘贴刚刚复制的内容。</p><!-- ![avatar](../pic/20211025/github_ssh.png) --><p><img src="https://zhouyi.me/pic/20211025/github_ssh.png" alt="avatar"></p><p>此时命令提示符输入如下命令会提示添加成功。</p><pre class="highlight"><code class="">ssh -T git@github.comHi zhouzhou84751! You've successfully authenticated, but GitHub does not provide shell access.</code></pre><h3 id="部署hexo"><a class="markdownIt-Anchor" href="#部署hexo"></a> 部署hexo</h3><p>在本地选择一个你喜欢的文件夹目录，初始化hexo。<br>在命令行输入以下命令初始化。</p><pre class="highlight"><code class="">hexo init myblog // 初始化hexo s // 部署在本地服务器 默认端口为4000</code></pre><!-- ![avatar](../pic/20211025/hexo_s.png) --><p><img src="https://zhouyi.me/pic/20211025/hexo_s.png" alt="avatar"></p><p>接着打开浏览器输入<code>localhost:4000</code>，出现如下页面则表示部署成功。</p><!-- ![avatar](../pic/20211025/hexo_helloword.png) --><p><img src="https://zhouyi.me/pic/20211025/hexo_helloword.png" alt="avatar"></p><p>部分的目录结构如下：</p><pre class="highlight"><code class="">// 模板目录 如输入hexo n post hello时会以此目录下的post.md为模板在source/_posts新建hello.md- scaffolds// 博文目录- source/_posts// 配置文件- _config.yml// 主题文件夹- themes</code></pre><p>常用的几个命令如下：</p><pre class="highlight"><code class="">// []表示可以省略的内容 &lt;&gt;表示变量名，即输入的参数// 新建文章，未指定layout则默认使用_config.yml中的default_layout参数的layouthexo n [layout] &lt;title&gt;// 清除缓存文件和生成静态文件，常在做了大改动的情况下使用，否则网站有可能会改动不生效hexo clean// 生成静态文件，部署到github前记得调用hexo g// 启动服务器，通常是部署到本地给自己看的hexo s// 部署网站，即部署到githubhexo d</code></pre><p>更改配置文件<code>_config.yml</code>。</p><pre class="highlight"><code class="">title: my blog // 网站标题author: zhouzhou84751 // 作者language: zh-CN // 语言url: https://zhouzhou84751.github.io/ // github pages的url，如果自定义域名也需要更改theme: landscape // 主题设置deploy:  type: 'git'  repo: git@github.com:zhouzhou84751/zhouzhou84751.github.io.git // 项目地址，推荐填入ssh的地址  branch: main // 项目分支 默认是main</code></pre><p>基础配置完毕后，安装<code>hexo-deployer-git</code>插件。更多说明请参照<a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a>。</p><pre class="highlight"><code class="">npm install hexo-deployer-git --save</code></pre><p>部署到github pages。</p><pre class="highlight"><code class="">hexo cleanhexo ghexo d</code></pre><p>每次部署最好都执行clean和generate命令，这样每次输入三个命令太麻烦了，我们可以添加到hexo项目中的<code>package.json</code>中<code>scripts</code>中，新建一个upload变量如下所示。</p><pre class="highlight"><code class="">  &quot;scripts&quot;: &#123;    // 默认命令    &quot;build&quot;: &quot;hexo generate&quot;,    &quot;clean&quot;: &quot;hexo clean&quot;,    &quot;deploy&quot;: &quot;hexo deploy&quot;,    &quot;server&quot;: &quot;hexo server&quot;,    // 新建一个upload 注意上面加一个,    &quot;upload&quot;: &quot;hexo clean&amp;&amp;hexo generate&amp;&amp;hexo deploy&quot;  &#125;,</code></pre><p>这样每次运行以下命令就可以直接一键三连部署。</p><pre class="highlight"><code class="">npm run upload</code></pre><h3 id="备份博客"><a class="markdownIt-Anchor" href="#备份博客"></a> 备份博客</h3><p>虽然我们将hexo博客部署到github.io项目上面，但是我们用来部署的源码依旧在本地，因此推荐新建一个<strong>私人仓库</strong>上传hexo项目，因为源码中的设置涉及到很多token之类的信息，最好不要设为公开项目。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;此博客介绍如何将Hexo部署到Github pages上。&lt;/p&gt;</summary>
    
    
    
    <category term="博客" scheme="https://zhouyi.me/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://zhouyi.me/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://zhouyi.me/2021/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://zhouyi.me/2021/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-24T05:54:59.000Z</published>
    <updated>2022-02-12T12:18:15.685Z</updated>
    
    <content type="html"><![CDATA[<p>此文介绍常见的排序算法。</p><span id="more"></span><h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">常见排序算法</a></li><li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li><li><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li><li><a href="#%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">简单插入排序</a></li><li><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li><li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li><li><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li><li><a href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83">排序算法比较</a></li></ul><h3 id="常见排序算法"><a class="markdownIt-Anchor" href="#常见排序算法"></a> 常见排序算法</h3><ul><li>冒泡排序</li><li>选择排序</li><li>简单插入排序</li><li>希尔排序</li><li>归并排序</li><li>快速排序</li><li>堆排序</li></ul><p>本文中图来自于菜鸟教程的<a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大经典排序</a>。</p><h3 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="avatar"><br>顾名思义，冒泡排序就是两两比较，将最大的放在最底下，利用如同冒泡一样将元素上升的方法。<br>由于比较基础也比较容易理解，直接上代码。</p><pre class="highlight"><code class="java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-keyword">boolean</span> isSort = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 增加标志位，如果一个循环里没有发生数据交换，则证明已经排序好了</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length &amp;&amp; !isSort; i++) &#123;        <span class="hljs-comment">// 每次让最大的泡泡升出来</span>          isSort = <span class="hljs-keyword">true</span>;          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; arr.length - i; j++) &#123;              <span class="hljs-keyword">if</span> (arr[j-<span class="hljs-number">1</span>] &gt; arr[j]) &#123;                  <span class="hljs-keyword">int</span> temp = arr[j-<span class="hljs-number">1</span>];                  arr[j-<span class="hljs-number">1</span>] = arr[j];                  arr[j] = temp;                  isSort = <span class="hljs-keyword">false</span>;              &#125;          &#125;      &#125;  &#125;</code></pre><ul><li>时间复杂度<br>最好情况是O(n)，排序好了的情况，此时只比较但不用交换。<br>最坏情况都没排序好，此时经过<code>(n-1)+(n-2)+...+1 = n(n-1)/2</code>次比较，时间复杂度为O(n^2)。<br>平均时间复杂度为O(n^2)。</li><li>空间复杂度<br>不需要借助额外的开辟新数组的空间，为O(1)。</li></ul><h3 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="avatar"><br>类似打擂台的方法，每次循环选出一个值跟所有值比较，最后最小值胜出。<br>也比较容易理解，直接上代码。</p><pre class="highlight"><code class="java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;          <span class="hljs-keyword">int</span> minIndex = i;          <span class="hljs-comment">// 选出最小值的索引</span>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;              <span class="hljs-keyword">if</span> (arr[j]&lt;arr[minIndex]) &#123;                  minIndex = j;              &#125;          &#125;          <span class="hljs-comment">// 交换最小值到“擂台”</span>          <span class="hljs-keyword">if</span> (minIndex != i) &#123;              <span class="hljs-keyword">int</span> temp = arr[i];              arr[i] = arr[minIndex];              arr[minIndex] = temp;          &#125;      &#125;  &#125;</code></pre><ul><li>时间复杂度<br>最好最坏情况都需要进行<code>n(n-1)/2</code>次比较，时间复杂度为O(n^2)。</li><li>空间复杂度<br>不需要借助额外的开辟新数组的空间，为O(1)。</li></ul><h3 id="简单插入排序"><a class="markdownIt-Anchor" href="#简单插入排序"></a> 简单插入排序</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="avatar"><br>两两比较，比较的过程中，元素一直往后移。<br>结合动图理解起来也比较直观，上代码。</p><pre class="highlight"><code class="java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;          <span class="hljs-keyword">int</span> j = i;          <span class="hljs-keyword">int</span> temp = arr[j]; <span class="hljs-comment">// 先把要插入的数挖出来</span>          <span class="hljs-comment">// 当要插入的数比前一个数小的时候，前面元素往后移</span>          <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; temp &lt; arr[j - <span class="hljs-number">1</span>]) &#123;              arr[j] = arr[j - <span class="hljs-number">1</span>];              j--;          &#125;          arr[j] = temp;      &#125;  &#125;</code></pre><ul><li>时间复杂度<br>最好情况仅需要经过<code>n-1</code>次比较，不需要交换，为O(n)。<br>最坏情况为O(n^2)。</li><li>空间复杂度<br>不需要借助额外的开辟新数组的空间，为O(1)。</li></ul><h3 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif" alt="avatar"><br>希尔排序是插入排序的一种优化方案，插入排序中的元素后移比价浪费时间，因为每次都只能移动一个位置交换相邻的元素。<br>希尔排序通过设置一个增量值即间隔，直接根据增量来达到交换不相邻的元素，每次可以将逆序数数量减少大于1。<br>如3,2,1有两个逆序对，若通过简单插入排序，一次只能消除一个逆序对。通过希尔排序则可以让3和1直接交换，达到消除多对逆序对的效果。<br>另外，简单插入排序对于数组部分有序的逆序对较少的情况，时间复杂度也比较低。<br>综合上述，首先大幅度减少逆序对，之后再不断减少增量值，最后便转化为简单插入排序，此时已经部分有序，所以效果比直接用插入排序算法要好得多。</p><pre class="highlight"><code class="java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-comment">// 在此我们将增量设置为length/2 每次缩小一半</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> step = arr.length/<span class="hljs-number">2</span>; step &gt;<span class="hljs-number">0</span> ; step/=<span class="hljs-number">2</span>) &#123;          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = step; i &lt; arr.length; i++) &#123;              <span class="hljs-keyword">int</span> j = i;              <span class="hljs-keyword">int</span> temp = arr[j];              <span class="hljs-keyword">while</span> (j &gt;= step &amp;&amp; temp &lt; arr[j - step]) &#123;                  <span class="hljs-keyword">int</span> t = arr[j];                  arr[j] = arr[j - step];                  arr[j - step] = t;                  j -= step;                  System.out.println(Arrays.toString(arr));              &#125;              arr[j] = temp;          &#125;      &#125;  &#125;</code></pre><ul><li>时间复杂度<br>据说是1959年Shell发明的，第一个突破O(n^2)的排序算法。<br>复杂度难以分析，所以在此省略分析过程，平均复杂度为O(nlogn)。</li><li>空间复杂度<br>不需要借助额外的开辟新数组的空间，为O(1)。</li></ul><h3 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="avatar"><br>归并排序主要采用了分治和递归的思想。如上图所示，二路归并是将数据平分成两组各自进行排序，之后再将这两组排序的结果再进行排序，一直递归调用。<br>代码如下：</p><pre class="highlight"><code class="java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;    <span class="hljs-keyword">if</span>(left&lt;right)&#123;      <span class="hljs-keyword">int</span> middle = (left + right)/<span class="hljs-number">2</span>;      sort(arr, left, middle);      sort(arr, middle+<span class="hljs-number">1</span>, right);      merge(arr, left, right);    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;    <span class="hljs-keyword">int</span> middle = (left + right)/<span class="hljs-number">2</span>;    <span class="hljs-comment">// 开辟一个新数组用来存储排序后的结果</span>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[right - left + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> i = left;    <span class="hljs-keyword">int</span> j = middle + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(i &lt;= middle &amp;&amp; j&lt;=right)&#123;      <span class="hljs-keyword">if</span>(arr[i] &lt; arr[j])&#123;        temp[t++] = arr[i++];      &#125;<span class="hljs-keyword">else</span>&#123;        temp[t++] = arr[j++];      &#125;    &#125;    <span class="hljs-keyword">while</span>(i&lt;=middle)&#123;      temp[t++] = arr[i++];    &#125;    <span class="hljs-keyword">while</span>(j&lt;=right)&#123;      temp[t++] = arr[j++];    &#125;    <span class="hljs-comment">// 记得将数组内容赋值回原数组</span>    t = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(left&lt;=right)&#123;      arr[left++] = temp[t++];    &#125;  &#125;</code></pre><ul><li>时间复杂度<br>和选择排序一样，归并排序的性能并不受输入数据的影响，但是表现却要比选择排序优秀得多。<br>归并排序是一种十分高效的稳定的排序，可以看到每次合并的操作时间复杂度为O(n)，而完全二叉树的深度为log2n，因此总的来说，归并算法的时间复杂度为O(nlogn)，并且永远是O(nlogn)。</li><li>空间复杂度<br>归并排序的代价就是需要额外的内存空间，必须新开辟一块内存空间用来暂存合并之后的数组。因此空间复杂度为O(n)。</li></ul><h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="avatar"><br>如果说归并排序是先局部有序，然后整体有序，那么快速排序正好相反，快速排序可以理解为先整体有序，再局部有序。<br>具体的排序思想是，先找出一个基准(pivot)，之后将比基准大的值放在基准的后面，而小的值放在前面，也就是说，每次的排序相当于将这个基准值归位。<br>之后再递归地将基准左右的值进行快速排序。<br>代码如下：</p><pre class="highlight"><code class="java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;    <span class="hljs-keyword">if</span>(left&lt;right)&#123;      <span class="hljs-keyword">int</span> pivot = arr[left];      <span class="hljs-keyword">int</span> i = left;      <span class="hljs-keyword">int</span> j = right;      <span class="hljs-keyword">while</span>(i &lt; j)&#123;        <span class="hljs-comment">// 从右开始往左寻找第一个比基准小的值</span>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; arr[j] &gt; pivot)&#123;          j--;        &#125;        <span class="hljs-comment">// 放入左边的坑中，此时j的位置相当于一个坑</span>        <span class="hljs-keyword">if</span>(i &lt; j)&#123;          arr[i] = arr[j];          i++;        &#125;        <span class="hljs-comment">// 从左往右开始寻找第一个比基准大的值</span>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt; pivot)&#123;          i++;        &#125;        <span class="hljs-comment">// 放入右边的坑中</span>        <span class="hljs-keyword">if</span>(i &lt; j)&#123;          arr[j] = arr[i];          j--;        &#125;      &#125;      <span class="hljs-comment">// 此时i和j相等，将基准放入这个坑中</span>      arr[i] = pivot;      sort(arr, left, i-<span class="hljs-number">1</span>);      sort(arr, i+<span class="hljs-number">1</span>, right);    &#125;  &#125;</code></pre><ul><li>时间复杂度<br>快速排序的最坏情况是O(n^2)，当数组有序的时候（所有元素都相同），不论正序倒序，就会出现循环了两次。<br>解决方法是随机选择pivot或者随机打乱数组。<br>最好的情况是每次都正好对半分，如同归并算法一样像个完全二叉树一样，这样时间复杂度为O(nlogn)。<br>平均时间复杂度为O(nlogn)。</li><li>空间复杂度<br>快速排序是在原本的数组基础上排序的，无需辅助数组，但是递归调用需要辅助栈。<br>最坏情况为O(n)。递归了n次。<br>最好的情况为O(logn)。</li></ul><h3 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h3><p>两个概念：</p><ul><li>大顶堆：每个节点都大于或者等于其子节点的值，堆排序中用于升序排列。</li><li>小顶堆：每个节点都小于或者等于其子节点的值，堆排序中用于降序排列。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="avatar"></p><ul><li>完全二叉树：结点按照从上往下从左往右编号一一对应同样深度的满二叉树的对应位置的编号的二叉树。</li><li>满二叉树：深度为k时，有2^k - 1个结点的二叉树。<br>由于完全二叉树可以用编号对应结点的，因此数组中的index可以对应成一个完全二叉树的结点编号，因此我们可以将数组看成完全二叉树来处理。<br>假设根节点编号为0，二叉树中的孩子结点与双亲结点的编号关系：</li><li><code>left = root*2 + 1;</code></li><li><code>right = root*2 + 2;</code></li><li><code>parent = (root - 1)/2;</code></li></ul><p>根据上述关系，就可以将数组看成二叉树，进而转换成堆来进行排序。</p><p>步骤如下：</p><ul><li>构建大顶堆</li><li>将大顶堆的根结点与最后一个叶结点位置互换，去除叶结点</li><li>对去除最后一个结点的完全二叉树进行heapify操作</li><li>goto 步骤2</li></ul><pre class="highlight"><code class="java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;        buildHeap(nums);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-comment">// 将叶结点和根结点互换，并去除叶结点再堆化</span>            <span class="hljs-keyword">int</span> temp = nums[i];            nums[i] = nums[<span class="hljs-number">0</span>];            nums[<span class="hljs-number">0</span>] = temp;            <span class="hljs-comment">// i-1 代表去除了叶结点</span>            heapify(nums,<span class="hljs-number">0</span>,i-<span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-comment">// 构建大顶堆</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (len-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            heapify(nums,i,len);        &#125;    &#125;    <span class="hljs-comment">// 堆化操作</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;        <span class="hljs-keyword">int</span> lastRootIndex = start;        <span class="hljs-keyword">int</span> max = lastRootIndex;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">2</span>*lastRootIndex + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> right = <span class="hljs-number">2</span>*lastRootIndex + <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (left&lt;=end &amp;&amp; nums[left]&gt;nums[max])&#123;            max = left;        &#125;        <span class="hljs-keyword">if</span> (right&lt;=end &amp;&amp; nums[right]&gt;nums[max])&#123;            max = right;        &#125;        <span class="hljs-keyword">if</span> (max != lastRootIndex) &#123;            <span class="hljs-keyword">int</span> temp = nums[max];            nums[max] = nums[lastRootIndex];            nums[lastRootIndex] = temp;            heapify(nums,max,end);        &#125;    &#125;</code></pre><h3 id="排序算法比较"><a class="markdownIt-Anchor" href="#排序算法比较"></a> 排序算法比较</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="avatar"></p><ul><li>归并排序VS快速排序<ol><li>快速排序不稳定，归并排序是稳定的，能够保证原来的顺序。</li><li>归并排序需要借助额外的空间，不是原地排序算法。</li></ol></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;此文介绍常见的排序算法。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://zhouyi.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://zhouyi.me/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://zhouyi.me/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建相关</title>
    <link href="https://zhouyi.me/2021/09/24/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/"/>
    <id>https://zhouyi.me/2021/09/24/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2022-02-12T12:18:15.683Z</updated>
    
    <content type="html"><![CDATA[<p>此博客是根据github.io和hexo结合的方案搭建的静态个人博客，本文主要记录一下搭建过程中遇到的问题。</p><span id="more"></span><h3 id="hexo和github-pages"><a class="markdownIt-Anchor" href="#hexo和github-pages"></a> Hexo和Github pages</h3><p>关于如何将hexo部署到github pages请参考下面的教程。</p><ul><li><a href="https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%88%A9%E7%94%A8Hexo%E5%92%8CGithub-io%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/">利用Hexo和Github.io搭建静态博客</a></li></ul><h3 id="pure主题皮肤相关"><a class="markdownIt-Anchor" href="#pure主题皮肤相关"></a> pure主题皮肤相关</h3><p>hexo支持设置自己喜欢的主题，可以从<a href="https://hexo.io/themes/">此网站</a>挑选大佬们做好的模板。<br>此博客采用的皮肤为<a href="https://github.com/cofess/hexo-theme-pure">pure</a>。<br>另外，由于原作者暂时没有时间维护，有大佬出了一个保姆级<a href="https://hwame.top/20200520/hello-hexo-troubleshooting.html">魔改教程</a>。<br>里面关于皮肤的许多扩展改进进行了详细的说明，有需要的可以根据个人进行改动，注意是仅针对pure主题的。</p><h3 id="关于评论系统gitalk"><a class="markdownIt-Anchor" href="#关于评论系统gitalk"></a> 关于评论系统gitalk</h3><p>此博客采用的评论系统为gitalk，gitalk相关问题可以查看此篇博客：</p><ul><li><a href="https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%85%B3%E4%BA%8E%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9Fgitalk%E7%9A%84%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF/">关于个人博客评论系统gitalk的一些错误</a></li></ul><h3 id="绑定自定义域名和域名解析"><a class="markdownIt-Anchor" href="#绑定自定义域名和域名解析"></a> 绑定自定义域名和域名解析</h3><p>搭建好github pages还可以绑定自定义的域名。可以参考下面的教程。</p><ul><li><a href="https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%B0%86Github-io%E7%BB%91%E5%AE%9A%E5%88%B0Godaddy%E5%9F%9F%E5%90%8D/">将Github.io绑定到Godaddy域名</a></li></ul><h3 id="将网址收录到搜索引擎"><a class="markdownIt-Anchor" href="#将网址收录到搜索引擎"></a> 将网址收录到搜索引擎</h3><p>至此，博客已经搭建完成，最后为了能够在搜索引擎中搜索到个人博客，我们需要将网址收录到各个搜索引擎。</p><ul><li><a href="https://zhouyi.me/2021/10/25/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E5%B0%86github-io%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E5%9D%80%E6%94%B6%E5%BD%95%E5%88%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">将github.io个人博客网址收录到搜索引擎</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;此博客是根据github.io和hexo结合的方案搭建的静态个人博客，本文主要记录一下搭建过程中遇到的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="博客" scheme="https://zhouyi.me/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://zhouyi.me/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>递归算法学习</title>
    <link href="https://zhouyi.me/2021/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zhouyi.me/2021/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-08-15T05:51:46.000Z</published>
    <updated>2022-02-12T12:18:15.685Z</updated>
    
    <content type="html"><![CDATA[<p>从一个反转链表的算法题来学习递归算法。</p><span id="more"></span><h3 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h3><p>递归算法在编程中运用广泛，递归算法一般指的是在函数内部通过不断调用自身求解的一种方法。以一个求阶乘的函数举例，则如以下形式(n&gt;=1)：<br><code>test</code></p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> n;    &#125;    <span class="hljs-keyword">int</span> temp = func(n-<span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> res = n * temp;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><p>这是一个简单的递归的函数，结果res为n乘以n-1的阶乘，一直往下推，推到最后n为1的时候则开始返回。</p><h3 id="一般情况"><a class="markdownIt-Anchor" href="#一般情况"></a> 一般情况</h3><p>那么如何思考递归的过程比较好呢？可以从以下的一种形式分析：</p><pre class="highlight"><code class="javaScript">func(param1)&#123;    <span class="hljs-comment">// 调用自身的终止条件</span>    <span class="hljs-keyword">if</span> (endCondition) &#123;        <span class="hljs-keyword">return</span>;    &#125;    value = func(param2); <span class="hljs-comment">// 此处调用自身</span>&#125;</code></pre><p>函数的其余部分则视情况加入逻辑处理的部分。<br>首先我们考虑终止情况，是有个确定的返回值的，接着再往上走，只需记住一点，函数中调用自身之后返回的是已经处理好了的之前的结果。<br>比如阶乘算法中，n*temp，此时temp的结果就是计算好了的n-1的阶乘。<br>这样去思考，则思路会清晰很多。</p><h3 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h3><p>以一道简单的反转链表的问题举例，题目如下：</p><pre class="highlight"><code class="">输入一个单链表的表头，返回一个反转之后的链表的表头。如输入&#123; 1-&gt; 2 -&gt; 3&#125;，返回&#123; 3 -&gt; 2 -&gt; 1&#125;</code></pre><p>这道题很容易想到可以用入栈出栈的方法去做，当然也可以用递归的方法做。代码如下：</p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head)</span></span>&#123;    <span class="hljs-keyword">if</span>( head.next == <span class="hljs-keyword">null</span> )&#123;        <span class="hljs-keyword">return</span> head;    &#125;    ListNode res = reverse(head.next);    <span class="hljs-comment">// 此时res为处理好了的，即已经表头为head.next反转过后的结果</span>    <span class="hljs-comment">// 注意此时返回的表尾部是head.next, 因此我们要对接尾部和head自身</span>    head.next.next = head;    head.next = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><p>这是从尾部开始递归的情况，当然从头部开始递归也行。代码如下：</p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head)</span></span>&#123;    <span class="hljs-comment">// 从头部开始递归，那么头部的下一个节点结果是null，因此可以如下设计</span>    ListNode res = func (head, <span class="hljs-keyword">null</span>);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">func</span><span class="hljs-params">(ListNode head, ListNode node)</span></span>&#123;    <span class="hljs-comment">// head为头部，node为head指向的下一个节点</span>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> node;    &#125;    ListNode tmp = head.next;    head.next = node;    ListNode res = func(tmp, head);    <span class="hljs-keyword">return</span> res;&#125;</code></pre><p>这是从头部开始递归的，首先处理好头部然后再处理后面的，此时要注意一下终止条件，如果我们将终止条件设置为如下：</p><pre class="highlight"><code class="java"><span class="hljs-keyword">if</span> (head.next == <span class="hljs-keyword">null</span>)&#123;    <span class="hljs-keyword">return</span> head;&#125;</code></pre><p>则会出现结果返回只有一个尾部节点的情况。这是因为如果从头部开始递归的话，则需要注意，逻辑处理的部分是在判断终止条件之后执行的，正好跟尾递归相反，即使轮到自身节点是，已经处理好了自身之前的节点，自身则需要和处理好的节点对接，因此我们如果将终止条件的“自身节点”设置为尾部的next，即为null，则说明已经处理好了尾部及尾部之前的节点，返回值不会出错。<br>最后，如有错误，欢迎指正，虚心学习。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从一个反转链表的算法题来学习递归算法。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://zhouyi.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="https://zhouyi.me/tags/Java/"/>
    
    <category term="算法" scheme="https://zhouyi.me/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="编程" scheme="https://zhouyi.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="https://zhouyi.me/2021/08/14/%E5%85%B6%E4%BB%96/test/"/>
    <id>https://zhouyi.me/2021/08/14/%E5%85%B6%E4%BB%96/test/</id>
    <published>2021-08-13T18:09:05.000Z</published>
    <updated>2022-02-12T12:18:15.683Z</updated>
    
    <content type="html"><![CDATA[<p>this is a test page.</p><span id="more"></span><pre class="highlight"><code class="bash">$ hexo server</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;this is a test page.&lt;/p&gt;</summary>
    
    
    
    <category term="test" scheme="https://zhouyi.me/categories/test/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://zhouyi.me/2021/08/13/%E5%85%B6%E4%BB%96/hello-world/"/>
    <id>https://zhouyi.me/2021/08/13/%E5%85%B6%E4%BB%96/hello-world/</id>
    <published>2021-08-12T18:09:05.000Z</published>
    <updated>2022-08-17T19:00:11.717Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><pre class="highlight"><code class="bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><pre class="highlight"><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><pre class="highlight"><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><pre class="highlight"><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="test" scheme="https://zhouyi.me/categories/test/"/>
    
    
  </entry>
  
</feed>
